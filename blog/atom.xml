<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://kooku0.gihub.io/blog</id>
    <title>Kooku log Blog</title>
    <updated>2022-01-30T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://kooku0.gihub.io/blog"/>
    <subtitle>Kooku log Blog</subtitle>
    <icon>https://kooku0.gihub.io/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[컴포넌트를 어떻게 만들어야 할까?]]></title>
        <id>컴포넌트를 어떻게 만들어야 할까?</id>
        <link href="https://kooku0.gihub.io/blog/컴포넌트를-어떻게-만들어야할까"/>
        <updated>2022-01-30T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[프론트엔드에서의 설계방식의 변천사를 소개한 뒤 앞으로 어떻게 컴포넌트를 만들어야 할지 저의 생각을 이야기 해보겠습니다.]]></summary>
        <content type="html"><![CDATA[<p>프론트엔드에서의 설계방식의 변천사를 소개한 뒤 앞으로 어떻게 컴포넌트를 만들어야 할지 저의 생각을 이야기 해보겠습니다.</p><h2>Presentational and Container Components</h2><p>이전 jQuery로 프론트를 개발하던 시기에는 dom과 비즈니스 로직이 뒤섞여 코드가 짜여졌습니다. 이렇게 코드가 짜여지니 가독성이 매우 떨어지고, 버그와 에러는 항상 내재되어 있었습니다.<br/>
<!-- -->이런 문제를 해결하기 위해서 관심사를 분리하기 시작했습니다. 상태를 관리하는 곳, 비동기 로직을 처리하는 곳, 비즈니스 로직을 처리하는 곳, dom과 스타일을 보여주는 곳.<br/>
<!-- -->관심사 분리는 설계와 관련된 책을 읽으면 항상 등장하는 개념이지만, 프론트엔드 엔지니어들은 <a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0">Presentational and Container Components</a>로 많이 익숙할 것 같습니다.
Container Component에서는 비즈니스 로직을 처리하고 Presentational Component에서는 View를 처리하도록 컴포넌트를 분리한 패턴입니다.</p><p>이렇게 분리하면 뭐가 좋을까요? Container는 dom 과 style등 마크업을 하는데 전혀 관여하지 않고 여러 Presentaional Component들이 어떻게 동작해야하는지 관리합니다. store에 연결하여 데이터를 받아 presentaional component에 전달하고, presentaional component의 버튼이 클릭되면 어떻게 동작해야하는지 등도 container component가 관리하죠. 그리고 persentaional component는 스타일과 마크업만 신경씁니다.</p><p>이렇게 각 컴포넌트가 하는 역할이 분리되니 비즈니스 로직의 수정사항이 발생했을 때는 container component만 view의 수정사항이 발생했을 때는 presentaional component만 고치면 됩니다. 가독성과 유지보수성이 높아졌죠.</p><h2>절차적 프로그래밍과 객체지향 프로그래밍</h2><h3>절차적 프로그래밍</h3><p>객체지향을 공부하면 절차지향을 객체지향과 비교하며 많이 소개하곤 합니다. 프로그램을 작게 쪼개면 데이터(Data)와 프로세스(Process)로 나눌 수 있는데 프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 절차적 프로그래밍(Procedural Programming)이라고 부릅니다. 위에서 보았던 Presentaional and Container Components 패턴이 대표적인 절차적 프로그래밍입니다.</p><p>적차적 프로그래밍에서 이야기하는 데이터를 프론트에서는 dom 객체로 생각하고 프로세스를 dom 객체를 컨트롤하는 메서드 혹은 함수라 생각하면 될 것 같습니다. 절차적 프로그래밍에서는 많은 컴포넌트(presentaional component)들이 수동적입니다. 모든 처리가 Container Component에서 이루어지고 Presentational component들은 단지 데이터를 받아 보여주는 역할만 수행하기 때문입니다. 처음에는 이게 원하는 방식이었지만 하나의 Container Component가 너무 많은 Presentaional Component들을 handling할 때 문제가 생겼습니다. presentaional component가 많아지게 되면 많은 props drilling 그리고 ref를 통해 dom을 조작해야하는 경우가 있을 때 Container Componnt에는 매우 많은 비즈니스 로직이 들어가고 커지게 됩니다. A Presentaional Component를 handling하는 로직, B Presentaional Component를 controll하는 로직이 모두 하나의 컴포넌트에 있는 것이죠.</p><p><img src="./images/%EC%A0%88%EC%B0%A8%EC%A0%81-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.jpeg" alt="img"/></p><center><small><em>책임이 중앙집중된 절차적 프로그래밍 (참고: 오브젝트)</em></small></center><br/><h3>객체지향 프로그래밍</h3><p>객체지향 프로그래밍에서는 이를 지양합니다. 자신의 데이터는 스스로 처리하도록 프로세스를 데이터가 있는 곳으로 이동시키죠. 이렇게 되면 데이터와 프로세스가 동일한 모듈 내부로 위치하게 되고 각 모듈은 능동적으로 변하게 됩니다. A Component를 조작하는 비즈니스 로직이 A Component에 존재하게 되어 다른 Component에 의존하지 않게 되는 것이죠.</p><p><img src="./images/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D.jpeg" alt="img"/></p><center><small><em>책임이 분산된 객체지향 프로그래밍 (참고: 오브젝트)</em></small></center><br/><h2>각각의 장단점을 분석해보자</h2><p><code>Presentaional and Container Components</code> 와 객체지향 프로그래밍 모두 장단점이 분명했습니다.
<code>Presentaional and Container Components</code>에서는 관심사 분리가 확실했지만 props drilling과 container component가 관리하는 presentational component가 많아 container component가 복잡해진다.<br/>
<!-- -->객체지향 프로그래밍에서는 의존성이 줄어들고 관심사 props drilling이 일어나지 않지만 비즈니스 로직과 뷰가 한 컴포넌트에 존재함으로써 유지보수와 가독성이 우려된다.</p><h3>Container component 분리</h3><p>우선 <code>Presentaional and Container Components</code>의 단점을 해결할 수 있는 방법들을 생각해봅시다.<br/>
<!-- -->지금 딱 떠오르는 방법은 container component를 쪼개면 되지 않을까? 생각이 들었습니다. Container Component가 컨트롤하고 담당하는 부분을 쪼개면 container component가 작아지고 하나의 Container Component가 책임지고 있는 presentational component들이 적어지니 문제가 해결될 것 같기도 합니다. 하지만 이렇게 되면 container component들 끼리 소통하는 경우 props로 또 내려주거나 global store에 데이터를 넣어줘야합니다 ㅠㅠ 컨테이너를 쪼개긴 했지만 이를 위해 추가되어야 할 로직들이 많아졌습니다. 과연 올바른 방법일까요?</p><h3>Custom Hooks</h3><p>객체지향에서 가지고 있었던 문제였던 하나의 컴포넌트에서 뷰와 비즈니스 로직이 들어있던 문제는 어떻게 해결할 수 있을까요? react 16.7에서 hooks가 나왔고 custom hooks를 많은 개발자 들이 사용하게 되었습니다. 공통된 비즈니스 로직들을 추상화하여 custom hooks로 만들면? 컴포넌트 안에 들어있던 비즈니스 로직들을 어느정도 분리할 수 있지 않을까요?</p><p>여기서 또 고민인게... 과연 공통된 비즈니스 로직이 얼마나 되느냐인 겁니다. 실제로 각 컴포넌트가 할 일들은 매우 지역적이고 해당 컴포넌트에서만 사용될 로직이 대부분일 겁니다. 따라서 공통된 비즈니스 로직들을 hooks로 빼더라도 컴포넌트에 남아있는 비즈니스 로직이 많겠죠.</p><blockquote><p>최근 recoil 과 server-state library인 SWR &amp; react-query가 나오면서 이전 redux-saga &amp; redux-thunk 를 사용할 때 처럼 작성해야할 로직이 많지는 않을 것이라는게 다행이긴 할 것 같네요.</p></blockquote><h2>비즈니스 로직 쪼개기</h2><p>지금 문제는 컴포넌트에 들어가는 비즈니스 로직들이 많다는 것이기에 로직들을 역할에 따라 구별해야할 필요성이 생겼습니다. 이제 프론트에서 동작하는 비즈니스 로직들은 어떤게 있을지 구분해보겠습니다.</p><ul><li>서버와 통신하는 로직 (api)</li><li>dom을 조작하는 로직 (ref)</li><li>client-state 를 관리하는 로직 (redux, recoil, useState)</li><li>Event handler (button, input)</li></ul><p>더 있을 것 같지만 지금 생각나는건 이정도네요.</p><p>우선 위 4개의 로직들은 관심사가 다르니 구별해야하는건 확실한 것 같습니다.</p><p><strong>서버와 통신하는 로직</strong>은 react-query와 같은 server-state library를 사용하거나 custom-hooks로 모두 빼면 될 것 같습니다.</p><p><strong>dom을 조작하는 로직</strong>은 조금 애매하긴 하지만 추상화 시킬 수 있는 여지는 충분합니다. dom의 위치를 조작한다던가 scroll을 조작하는 건 custom-hooks로 뺄 수 있을 것 같습니다. 물론 매우 지역적인 로직일 경우에는 공통적인 부분만 custom-hooks로 처리하고 나머지는 callback function을 통해 처리할 수도 있을 것 같습니다.</p><p><strong>client-state</strong>의 경우 요즘 redux-toolkit 도 나오고 recoil도 나오면서 useSelector, useDispatch 등을 통해 한두줄로 짤 수 있습니다.</p><p><strong>Event-handler</strong>의 경우 대부분 해당 컴포넌트에서만 사용되는 경우가 많을꺼라 공통로직이 거의 없을 것이고 컴포넌트 내부에서 구현해야할 것 입니다.</p><h2>정리</h2><p>컴포넌트를 어떻게 쪼개냐에 따라 달라지겠지만 하나의 컴포넌트는 자신이 필요한 데이터는 자신이 요청해 받아오고 그 데이터를 functional 혹은 custom-hooks로 가공해 사용하게 됩니다.<br/>
<!-- -->Container Component에 있었던 Event handler는 컴포넌트 내부로 옮겨왔고, 자신의 컴포넌트에 있는 dom의 이벤트를 직접 핸들링합니다. 그리고 컴포넌트간의 통신은 props를 최대한 지양하고 global state를 통해 통신이 일어나도록 해야 합니다. props로 데이터를 전달하는 순간 절차적 프로그래밍으로 변모될 가능성이 농후하기 때문입니다. 따라서 컴포넌트 사이의 통신은 global state로, 컴포넌트의 비즈니스 로직들은 custom-hooks 혹은 컴포넌트 내부에서 일어나야 합니다. (공통 dom&amp;styled를 추상화 시킨 컴포넌트를 사용할 때에만 props를 사용해야 합니다.)</p><p>각각의 컴포넌트가 이전의 container component의 역할을 수행한다고는 하지만 그렇다고 presentational component가 완전히 사라지는건 아닙니다. 공통적으로 사용되는 button, input, dialog, alert 들은 재사용할 수 있는 dom, style 요소들이 많습니다. 이런 부분은 common component 혹은 styled component로 따로 빼서 재사용하면 중복되는 코드나 스타일도 줄일 수 있을 것 같습니다.</p><p><code>Presentaional and Container Components</code>와 뭐가 다르냐고 생각이 들 수 있습니다. <code>Presentaional and Container Components</code>가 비즈니스 로직을 처리하는 컴포넌트, view를 처리하는 컴포넌트로 관심사를 기준으로 컴포넌트를 구분했다면 이제는 컴포넌트를 책임과 역할 단위로 구분하고, 공통된 비즈니스 로직, 스타일, dom들을 추상화 시켜 뺌으로써 모든 컴포넌트가 작은 Container Component이자 Presentaional Component가 되는 것 입니다.</p><h2>정말로 이게 정답일까?</h2><p>각 컴포넌트가 자신이 해야할 일을 스스로하고 복잡한 비즈니스 로직을 쪼개고, 공통된 로직, dom, style은 추상화 시켰다. 이렇게만하면 모든 문제가 해결될까?<br/>
<!-- -->완벽한 정답은 없듯이 여기에도 문제점은 있다. 바로 성능이다. 서버야 비싼 서버를 사용하고 스펙을 올리면 그만이겠지만 프론트엔드는 유저의 디바이스에서 돌아가기에 불필요한 리렌더링이나 메모리를 잡아먹는 행위는 지양되어야만 한다. 위의 방식대로 ToDoList를 구현한다고 생각해보자. List Component 안에 Item Component가 있을 것이고, 이 Item Component는 객체지향에서 말하듯이 Item Component에서 일어나는 일을 스스로 처리할 것이다. Item에 삭제 버튼과 수정버튼, 우선순위조절 버튼 등 많은 기능들이 있다면 다른 컴포넌트에서 처리하는게 아니라 Item Component에서 처리될 것이다. 만약 Item이 천개라면 어떨까? Container Component가 있었다면 Item이 몇개가 되든 ContainerComponent안에 handler 하나씩만 구현하여 props로 내려주면 되지만 위의 방식대로 구현한다면 아이템 컴포넌트들이 각자 handler를 포함하고 있고 아이템의 수만큼 handler가 늘어날 것이다.</p><p>이렇듯 항상 트레이드오프는 존재한다. 훌륭한 설계는 적절한 트레이드오프의 결과물이고 적절한 트레이드오프는 좋은 어플리케이션을 만든다는 사실을 인지해야할 것 같다.</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[프론트엔드에서 테스트코드 짜기]]></title>
        <id>프론트엔드에서 테스트코드 짜기</id>
        <link href="https://kooku0.gihub.io/blog/프론트엔드에서-테스트코드 짜기"/>
        <updated>2021-12-21T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[개발관련 서적들을 읽으면 공통적으로 테스트코드작성의 중요성들을 언급하고 있습니다. 하지만 많은 개발자들, 특히 프론트엔드 개발자들 중 테스트코드를 짜는 사람들은 많지 않은 것 같습니다. 그렇다면 왜 테스트코드를 짜지 않을까요? 그리고 테스트코드를 어떻게 짜야할까요?]]></summary>
        <content type="html"><![CDATA[<p>개발관련 서적들을 읽으면 공통적으로 테스트코드작성의 중요성들을 언급하고 있습니다. 하지만 많은 개발자들, 특히 프론트엔드 개발자들 중 테스트코드를 짜는 사람들은 많지 않은 것 같습니다. 그렇다면 왜 테스트코드를 짜지 않을까요? 그리고 테스트코드를 어떻게 짜야할까요?</p><blockquote><p>&quot;테스트 코드가 가져다 주는 장점들을 알고 있지만 다른 단점들을 얘기하며 여전히 시도하려 하지 않고, 도입을 꺼리는 것은 테스트 주도 개발을 해보지 않았거나 제대로 운영해보지 못했기 때문이다.&quot;</p><p><a href="https://yorr.tistory.com/26">https://yorr.tistory.com/26</a></p></blockquote><h2>테스트코드를 짜는 이유</h2><p>테스트코드는 리펙토링할 때 꼭 필요한 존재입니다. 테스트코드를 짜놓고 리펙토링을 하게되면 리펙토링 하기 전 과 후의 결과가 동일하다는 것을 보장할 수 있죠. 그래서 개발서적들에서는 좋은 코드로 리펙토링하는 법을 가이드하기 전에 테스트코드를 작성하라고 항상 당부하고 있습니다. 리펙토링 뿐 아니라 새로운 기능이 추가되거나 기존 기능이 변경되었을 때 다른 기능들이 제대로 동작한다는 것을 보장할 수 있기에 유지보수 측면에서도 매우 중요합니다. 예상치 못한 에러를 미리 방지할 수 있죠.</p><h2>TDD</h2><p>테스트코드의 중요성이 높아지고 에자일이라는 개념이 들어오면서 TDD, BDD와 같은 방법론들이 생겨나기 시작했습니다. 짧은 개발 사이클을 반복하는 프로세스인 에자일을 개발방법론에 적용한 것 중 하나가 TDD 입니다. TDD는 요구사항을 검증하는 테스트 케이스를 먼저 작성한 후 테스트 케이스를 통과하기 위한 최소한의 코드를 생성하고, 코드에 대한 리펙토링을 진행하는 과정을 짧은 주기로 가져가는 방법론입니다. 어떤 기능을 추가했을 때 그 기능 뿐 아니라 다른 기능까지 또는 전체적인 프로세스가 잘 작동하지 않는 경우가 있기에 기능 하나를 추가할 때 테스트 코드를 작성하고 제대로 작동하는지 확인하면서 그 기능이 다른 기능에 영향을 미치는지 테스트 할 수 있습니다.</p><h2>프론트엔드와 궁합이 잘 맞는 BDD</h2><p>BDD는 Behavior Driven Development로 테스트를 시나리오 기반으로 작성하는 것을 말합니다. BDD에서는 여러 패턴들이 있으나 <a href="https://johngrib.github.io/wiki/junit5-nested/">JUnit5로 계층 구조의 테스트 코드 작성하기</a> 와 <a href="https://www.betterspecs.org/">Better Specs. Testing Guidelines for Developers</a>에 소개된 패턴으로 설명하겠습니다.</p><p><code>Describe</code> - <code>Context</code> - <code>It</code> 세 키워드를 이용해서 행동기반 테스트를 작성하게 됩니다.</p><table><thead><tr><th align="center">키워드</th><th align="center">설명</th></tr></thead><tbody><tr><td align="center">Describe</td><td align="center">설명할 테스트 대상을 명시</td></tr><tr><td align="center">Context</td><td align="center">테스트 대상이 놓인 상황을 설명</td></tr><tr><td align="center">It</td><td align="center">테스트 대상의 행동을 설명</td></tr></tbody></table><p>이렇게 테스트를 작성하게 되면 테스트코드를 계층화 시킬 수 있고 비즈니스 로직 혹은 유저의 행동의 분기에 따른 테스트 코드를 보기좋게 작성할 수 있습니다.</p><h2>Jest에서 BDD 적용하기</h2><p>프론트엔드에서 Unit test를 할 때 사용할 수 있는 라이브러리는 jest, mocha, jasmin 이 있는데 가장 많이 사용하고 있는 Jest로 BDD를 구현하는 예시를 들어보겠습니다.</p><p><img src="./images/test-lib-trend.png" alt="img"/></p><p>위에서 BDD를 Describe - Context - It 패턴을 이용한다고 했는데 Jest는 공식적으로 Describe It은 제공하고 Context는 제공하지 않습니다. 그래서 <a href="https://github.com/negativetwelve/jest-plugins/tree/master/packages/jest-plugin-context">jest-plugin-context</a> 플러그인을 따로 설치해줘야 합니다. jest-plugin-context는 루비에서 사용하고 있는 BDD 형식의 TDD <a href="http://rspec.info/">RSpec</a> 기반으로 만들어줬습니다.</p><blockquote><p>In RSpec, describe it used to wrap a set of tests against one functionality while context is to wrap a set of tests against one functionality under the same state.</p></blockquote><p><img src="./images/rspec.png" alt="img"/></p><h3>BDD로 Dialog 구현해보기</h3><p>Style을 제외한 기능적인 요소들만 BDD로 Dialog를 구현해보겠습니다.</p><h3>디자인</h3><p><img src="./images/dialog.png" alt="img"/></p><h4>기능 요구사항</h4><ul><li>title을 props로 받아 보여줘야 한다.</li><li>describtion을 props로 받아 보여줘야 한다.</li><li>닫기 버튼을 클릭하면 Dialog가 닫혀야 한다.</li><li>입력필드에 텍스트를 입력할 수 있어야 한다.</li><li>등록버튼을 누르면 입력필드에 입력한 내용이 api로 전달되어야 한다.</li><li>등록버튼을 눌렸을 때 입력필드에 입력한 내용이 없다면 console.error에 “에러가 발생했습니다.“ 로그가 찍혀야한다.</li></ul><p>TDD 방법론에 따라 테스트 코드를 먼저 작성해보겠습니다.</p><pre><code class="language-tsx">describe(&quot;Dialog&quot;, () =&gt; {
  const title = &quot;제목&quot;;
  const description = &quot;설명 블라블라블라&quot;;
  const handleClickClose = jest.fn();
  const handleClickSubmit = jest.fn();
  const spyOnConsoleError = jest.spyOn(console, &quot;error&quot;);

  const renderDialog = () =&gt;
    render(
      &lt;Dialog
        title={title}
        description={description}
        onClickClose={handleClickClose}
        onClickSubmit={handleClickSubmit}
      /&gt;
    );

  it(&quot;title과 description이 보여야 한다.&quot;, () =&gt; {
    const { container } = renderDialog();

    expect(container).toHaveTextContent(title);
    expect(container).toHaveTextContent(description);
  });

  context(&quot;닫기 버튼을 누르면&quot;, () =&gt; {
    it(&quot;handleClickClose가 호출되어야 한다.&quot;, () =&gt; {
      renderDialog();

      fireEvent.click(screen.getByText(&quot;닫기&quot;));

      expect(handleClickClose).toBeCalled();
    });
  });

  context(&quot;등록버튼을 눌렀을 때&quot;, () =&gt; {
    context(&quot;입력된 텍스트가 없다면&quot;, () =&gt; {
      it(&#x27;console.error에 &quot;에러가 발생했습니다.&quot; 문구가 찍혀야 한다.&#x27;, () =&gt; {
        renderDialog();

        fireEvent.click(screen.getByText(&quot;등록&quot;));

        expect(spyOnConsoleError).toBeCalledWith(&quot;에러가 발생했습니다.&quot;);
      });
    });

    context(&quot;입력된 텍스트가 있다면&quot;, () =&gt; {
      const sampleText = &quot;sample-text&quot;;

      it(&quot;handleClickSubmit에 입력값이 전달되어야 한다.&quot;, () =&gt; {
        renderDialog();

        fireEvent.change(screen.getByPlaceholderText(&quot;contents&quot;), {
          target: { name: &quot;contents&quot;, value: sampleText },
        });
        fireEvent.click(screen.getByText(&quot;등록&quot;));

        expect(handleClickSubmit).toBeCalledWith(sampleText);
      });
    });
  });
});
</code></pre><p>모든 스펙에 대한 테스트코드 와 분기를 <code>Describe</code>, <code>context</code>, <code>It</code>을 이용해 작성했습니다.</p><p>테스트만 작성했지만 해당 컴포넌트에 어떤 props가 들어갈지, props에 대해 어떻게 내용이 보일지 개발자가 아닌 사람들도 추측할 수 있게 되었습니다.</p><pre><code class="language-tsx">interface Props {
  title: string;
  description: string;
  onClickClose: MouseEventHandler;
  onClickSubmit: (value: string) =&gt; null;
}

function Dialog({ title, description, onClickClose, onClickSubmit }: Props) {
  const [state, setState] = useState({ contents: &quot;&quot; });

  function handleChange(event: any) {
    const { value, name } = event.target;

    setState({
      ...state,
      [name]: value,
    });
  }

  function handleClickSubmit() {
    if (!state.contents) {
      console.error(&quot;에러가 발생했습니다.&quot;);
      return;
    }

    onClickSubmit(state.contents);
  }

  return (
    &lt;div&gt;
      &lt;h2&gt;{title}&lt;/h2&gt;
      &lt;div&gt;{description}&lt;/div&gt;
      &lt;div&gt;
        &lt;input
          type=&quot;text&quot;
          placeholder=&quot;contents&quot;
          name=&quot;contents&quot;
          onChange={handleChange}
          value={state.contents}
        /&gt;
      &lt;/div&gt;
      &lt;div&gt;
        &lt;button type=&quot;button&quot; onClick={onClickClose}&gt;
          닫기
        &lt;/button&gt;
        &lt;button type=&quot;button&quot; onClick={handleClickSubmit}&gt;
          등록
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre><p><img src="./images/test.png" alt="img"/></p><h2>마무리</h2><p>unit test만 작성해도 리펙토링에 매우 자유로워지는 것 같습니다. 테스트코드를 작성하지 않았다면 작성해보는게 어떨까요? 프론트엔드에서 테스트코드 작성이 어렵게 느껴졌었다면 이번 기회에 쉽게 다가왔으면 좋겠습니다.</p><h2>Reference</h2><ul><li><a href="https://johngrib.github.io/wiki/junit5-nested/">https://johngrib.github.io/wiki/junit5-nested/</a></li><li><a href="https://www.popit.kr/bdd-behaviour-driven-development%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B0%84%EB%9E%B5%ED%95%9C-%EC%A0%95%EB%A6%AC/">https://www.popit.kr/bdd-behaviour-driven-development%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B0%84%EB%9E%B5%ED%95%9C-%EC%A0%95%EB%A6%AC/</a></li><li><a href="https://yorr.tistory.com/26">https://yorr.tistory.com/26</a></li></ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[컴포넌트 응집도]]></title>
        <id>컴포넌트 응집도</id>
        <link href="https://kooku0.gihub.io/blog/컴포넌트-응집도"/>
        <updated>2021-11-17T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[보통 모듈의 독립성을 판단하는 지표로 응집도와 결합도를 이야기합니다. 응집도는 높을수록 좋고 결합도는 낮을수록 좋다는 이야기를 많이 들어봤는데 프론트엔드에서 어떻게 적용할 수 있을지 적어보았습니다.]]></summary>
        <content type="html"><![CDATA[<p>보통 모듈의 독립성을 판단하는 지표로 응집도와 결합도를 이야기합니다. 응집도는 높을수록 좋고 결합도는 낮을수록 좋다는 이야기를 많이 들어봤는데 프론트엔드에서 어떻게 적용할 수 있을지 적어보았습니다.</p><h2>응집도란</h2><p>응집도는 모델이 책임지는 역할을 위해서 필요한 데이터와 메소드들이 얼마나 밀접하게 연관되어 있는지를 이야기 합니다.</p><h2>왜 응집도가 높아야 할까?</h2><p>응집도가 높으면 다음과 같은 장점이 있습니다.</p><h3>1. 이해하기 쉽다.</h3><p>높은 응집도는 컴포넌트의 목적을 명확히 합니다. 모듈은 하나의 기능만 하고 모듈의 요소들은 이 하나의 기능을 위해서 함께 작동하게 됩니다.</p><h3>2. 테스트하기 쉽다.</h3><p>위의 내용과 연관되지만 컴포넌트가 하나의 일만 하기에 테스트하기 쉽습니다. 응집도가 높은 컴포넌트는 하나의 기능만 수행하기에 예측하기 쉽고, input에 대해 혹은 interface를 바탕으로 컴포넌트가 예측한 일을 수행하고 있는지만 테스트하면 됩니다.</p><h3>3. 재사용하기 쉽다.</h3><p>응집도가 높은 컴포넌트는 뒤죽박죽 임의로 선택된 데이터와 메소드로 구성되지 않고 컴포넌트를 구성하는 모든 요소들은 서로 공유하는 중요한 목적이 있습니다.</p><h3>4. 유지보수하기 쉽다.</h3><p>응집도가 높은 컴포넌트는 컴포넌트 변경의 이유가 한 개이고, 코드의 변경이 발생했을 때 변경이 여러 컴포넌트로 분산되지 않고 단일 컴포넌트에서 발생하기에 유지보수하기 쉽습니다.</p><h2>응집도를 높히는 법</h2><h3>테스트를 먼저 작성하라</h3><p>테스트코드를 내 코드가 올바르게 동작하도록 검증해주는 단순한 도구가 아니라 응집도 있는 설계, 사용하기 좋은 코드를 만드는데 도움이 되는 도구로 활용할 수 있습니다. 높은 응집도를 가진 모듈은 이해하기 쉽고 의도를 파악하기 쉬우며 테스트하기 쉽다고 했습니다. 그렇다고 높은 응집도를 가진 것이 좋은게 아니라 그 목적에 맞게 필요한 만큼만 응집되어 있어야 합니다. 그리고 응집도는 컴포넌트를 나누는 기준이 됩니다.</p><p>만약 하나의 컴포넌트를 테스트하는 테스트코드가 늘어나면 컴포넌트를 더 작게 나눠야하는 신호로 받아들여야 합니다.</p><h3>REP: 재사용/릴리즈 등가 원칙</h3><blockquote><p>재사용 단위는 릴리즈 단위와 같다.</p></blockquote><p>:::note</p><p>해당 내용은 클린 아키텍처 책에서 가져온 내용입니다. 클린 아키텍처에서는 컴포넌트를 프론트엔드와는 조금 다르게 설명하지만(클래스들의 묶음) 본질적인 내용은 같기에 프론트엔드 컴포넌트의 관점으로 설명하겠습니다.</p><p>:::</p><p>이 원칙은 소프트웨어 설계와 아키텍처 관점에서 보면 단일 컴포넌트는 응집성 높은 요소들(데이터 &amp; 함수)로 구성되어야 함을 뜻합니다. 단순히 뒤죽박죽 임의로 선택된 요소들로 구성되어서는 안됩니다. 컴포넌트를 구성하는 모든 요소는 서로 공유하는 중요한 목적이 있어야 합니다.</p><h3>CCP: 공통 폐쇄 원칙</h3><blockquote><p>동일한 시점에 동일한 이유로 변경하는 것들을 한데 묶어라. 서로 다른 시점에 다른 이유로 변경되는 것들을 서로 분리하라.</p></blockquote><p>동일한 이유로 동일한 시점에 변경되는 요소를 같은 컴포넌트로 묶어야하고 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리해야 합니다. 이 원칙은 단일 책임 원칙(SRP)를 컴포넌트 관점에서 다시 쓴 것입니다. SRP에서 단일 클래스는 변경의 이유가 여러 개 있어서는 안 된다고 말하듯이, 공통 폐쇄 원칙에서도 마찬가리로 하나의 컴포넌트는 변경의 이유가 여러 개 있어서는 안 됩니다.</p><p>대다수의 애플리케이션에서 유지보수성은 재사용성보다 훨씬 중요합니다. 코드가 반드시 변경되어야 한다면, 이러한 변경이 여러 컴포넌트에 분산되어 발생하기 보다는, 차리리 변경 모두가 단일 컴포넌트에서 발생하는 편이 낫습니다.</p><p>CCP는 이런 이유로 변경될 가능성이 있는 요소는 모두 한 곳으로 묶을 것을 권합니다. 물리적 또는 개념적으로 강하게 결합되어 항상 함께 변경되는 클래스들은 하나의 컴포넌트에 속해야 합니다.</p><p>이 원칙은 개방 폐쇄 원칙(OCP)와도 밀접하게 연관되어 있습니다. 실제로 CCP에서 말하는 폐쇄는 OCP에서 말하는 폐쇄와 그 뜻이 같습니다.
CCP에서는 동일한 유형의 변경에 대해 닫혀 있는 클래스들을 하나의 컴포넌트로 묶음으로써 OCP에서 얻은 교훈을 그대로 적용할 수 있습니다. 따라서 변경이 필요한 요구사항이 발생했을 때, 그 변경이 영향을 주는 컴포넌트들이 최소한으로 한정될 가능성이 높아지게 됩니다.</p><h3>CRP: 공통 재사용 원칙</h3><blockquote><p>필요하지 않는 것에 의존하게 강요하지 말라.</p></blockquote><p>CRP도 요소들을 어느 컴포넌트에 위치시킬지 결정할 때 도움이 되는 원칙입니다. CRP에서는 같이 재사용되는 경향이 있는 요소들은 같은 컴포넌트에 포함해야 한다고 말합니다. 대체로 재사용 가능한 요소들은 재사용 컴포넌트의 일부로써 해당 컴포넌트의 다른 요소들과 상호작용하는 경우가 많습니다. CRP에서는 이런 요소들이 동일한 컴포넌트에 포함되어야 한다고 말합니다. 이러한 컴포넌트 내부에서는 요소들 사이에 수많은 의존성이 있으리라고 예상할 수 있습니다.</p><p>다른 컴포넌트와 의존성이 조금이라도 발생하면 재사용성이 떨어지게 됩니다. 따라서 CRP는 강하게 결합되지 않는 요소들을 동일한 컴포넌트에 위치시켜서는 안된다고 말합니다.</p><h2>Reference</h2><ul><li>FEConf2021 한윤석님의 &quot;우리는 응집도에 대하여 이야기할 필요가 있다&quot;</li><li>[클린 아키텍처]<!-- --> 로버트 C. 마틴</li></ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React에서 side effect를 관리하는 법]]></title>
        <id>React에서 side effect를 관리하는 법</id>
        <link href="https://kooku0.gihub.io/blog/react에서-side-effect를-관리하는-법"/>
        <updated>2021-11-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[요즘 스칼라로 배우는 함수형 프로그래밍 책을 읽고 있습니다.]]></summary>
        <content type="html"><![CDATA[<p>요즘 <code>스칼라로 배우는 함수형 프로그래밍</code> 책을 읽고 있습니다.</p><p><img src="../images/functional-book.jpeg"/></p><p>아직 2장 밖에 읽지 않았지만, 기억에 남는 문장들이 몇 개 있습니다.</p><p>:::note</p><p>함수형 프로그래밍은 부수 효과가 없는 순수 함수들로만을 이용해 프로그램을 구축하는 것을 의미한다.</p><p>부수 효과가 없다는 것은 주어진 값에 대해 이 함수는 항상 같은 값을 돌려주는 것을 보장한다. 그리고 그 이외의 일은 <strong>전혀</strong> 일어나지 않는다.</p><p>순수함수는 하나의 블랙박스이다. 입력은 항상 함수에 대한 인수들로만 주어진다. 그리고 함수는 결과를 계산해서 돌려줄 뿐, 그것이 어떻게 쓰이는지는 신경 쓰지 않는다. 이러한 관심사의 분리 덕분에 계산 논리의 재사용성이 높아진다.</p><p>:::</p><p>이 책에서는 순수함수를 만들기 위해 &quot;어쩔 수 없이 사용하게 되는 부수효과들은 함수의 밖으로 밀어내고 함수가 하는 일을 최대한 작게 들어라. 그래야 함수를 재사용할 수 있고 테스트도 용이하다&quot;고 말합니다.</p><p>이때 함수형 프로그래밍의 철학을 프론트엔드에 적용해보고 싶다는 생각이 들었습니다. 사실 React에서는 이미 <code>Pure Component</code>, <code>Container and Presentational Pattern</code>, <code>redux-saga</code>를 보면 알듯이 이미 순수에 대한 개념이 많이 들어와 있긴 합니다.</p><p><code>React.memo</code>와 <code>Pure Component</code>를 만들어 불필요한 re-rendering를 막게 한다던가, Bussiness Logic과 View를 담당하는 Component를 분리한다던가 (유지보수성과도 연관이 있겠지만 View를 담당하는 Component에서 side effect를 일으키는 것들을 component 밖으로 밀어내 Container Component에서 관리하게 하는 역할도 있다고 생각합니다.) Redux에서는 상태관리만 하고 그 외의 비동기 작업, api 통신, 에러처리와 같은 부수효과를 일으키는 작업들은 redux-saga에서 따로 관리하도록 말이죠. (실제로 redux-saga 공식문서의 첫화면이 &quot;An intuitive Redux side effect manager.&quot; 입니다.)</p><p><a href="https://redux-saga.js.org/">https://redux-saga.js.org/</a></p><p><img src="../images/redux-saga.png"/></p><p>functional programming이 pure function들의 조합으로 프로그램을 구성한다고는 하지만 부수효과가 없는 프로그램은 없다고 생각합니다. functional programming은 코드문맥에서 발생하는 공통의 패턴을 함수로 만들어 재사용하게 함을 목적으로 둔다고 생각합니다. 이때의 함수는 순수함수겠죠.
그리고 프론트에서도 공통적으로 사용되는 컴포넌트를 pure component로 만듦으로써 재사용이 가능하게 하고 테스트하기 쉽게 만들기 위해 functional programming의 철학이 필요하다고 생각합니다.</p><h2>Pure Component를 만드는 법</h2><p>책에서 나왔듯이 component에서 side effect가 발생하는 부분들을 최대한 밖으로 밀어내야 합니다. container component로 side-effect를 모두 빼거나, custom hooks에서 처리하게 해야합니다. 만약 redux를 사용한다면 redux-saga에서 처리하게 해야합니다.</p><p>이렇게 하면 props에 대해 컴포넌트가 어떻게 렌더링될지 예상할 수 있고 테스트하기도 쉬워집니다. props에 따라 글자나 style의 결과만 테스트하면 됩니다.</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[마이크로서비스 아키텍처를 모노레포로 관리하기]]></title>
        <id>마이크로서비스 아키텍처를 모노레포로 관리하기</id>
        <link href="https://kooku0.gihub.io/blog/마이크로서비스-아키텍처를-모노레포로-관리하기"/>
        <updated>2021-10-30T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[알고 들어야 하는 내용]]></summary>
        <content type="html"><![CDATA[<h2>알고 들어야 하는 내용</h2><h3>Microservices Architecture &amp; Monolithic Architecture</h3><blockquote><p>Microservices Architecture &amp; Monolithic Architecture
주로 백엔드에서 많이 다루는 내용이긴 하지만 프론트엔드 입장에서 서술하겠습니다.<br/>
<!-- -->frontend에서는 msa를 microservices가 아닌 microfrontends로 많이 불립니다.</p></blockquote><p>최근 몇 년동안 MSA 돌풍이 불었습니다. MSA는 서비스들을 모듈단위로 작게 쪼개어 관리를 하는 것으로 예전부터 설계해온 Monolithic Architecture 와는 반대되는 아키텍처입니다.</p><p>MSA를 사용했을 때 여러 장점들이 있는데 거대한 서비스들을 작은 단위로 쪼갬으로써 빌드시간이 줄어들고 특정 부분의 장애가 전체 서비스의 장애로 이어지지 않고 장애가 발생한 특정 모듈만 교체함으로 써 문제해결이 가능하게 되었습니다.(가용성)</p><p>뿐만 아니라 배포나 버전관리도 전체 서비스단위로 하는게 아닌 업데이트가 필요한 모듈만 배포를 함으로써 유지보수성도 매우 높아졌습니다.</p><p>하지만 장점만 있는건 아니였습니다. 하나로 있던 모듈들을 쪼개버리니 공통으로 사용하고 있던 부분들이 모듈들에 중복으로 들어가게 되고, 모듈들이 통신하기 위한 중계 서비스 혹은 message queue(ex. kafka)의 사용이 필수가 됨으로써 서비스 자체의 크기가 더욱 커지게 되었습니다.</p><h2>Overview</h2><p>현재 회사의 프론트엔드 프로젝트는 마이크로서비스 아키텍처를 지향하며 개발하고 있습니다. 웹뷰의 경우 도메인 하나를 사용하지만 총 4개의 서비스들로 구성이 되어 있습니다.</p><table><thead><tr><th align="center">path</th><th align="center">description</th></tr></thead><tbody><tr><td align="center"><code>/a</code></td><td align="center">A 서비스</td></tr><tr><td align="center"><code>/b</code></td><td align="center">B 서비스</td></tr><tr><td align="center"><code>/c</code></td><td align="center">C 서비스</td></tr><tr><td align="center"><code>/d</code></td><td align="center">D 서비스</td></tr></tbody></table><p>네 개의 프로젝트를 다루면서 여러 장단점들이 있었는데 정리하면 다음과 같습니다.</p><h3>장점</h3><ul><li>프로젝트 별로 기술스택을 다르게 가져갈 수 있다.<ul><li>실제로 A 서비스는 vue, 다른 서비스들은 react로 개발하고 있습니다.</li></ul></li><li>프로젝트를 작게 가져감으로써 빌드 시간을 줄일 수 있다.</li></ul><h3>단점</h3><ul><li>여러 기술스택을 사용하니 다른 개발자들에게 부담이 될 수 있다.</li><li>새로운 서비스를 만들어야 할 때 프로젝트 셋팅을 처음부터 다시 해야한다.<ul><li>repo 생성</li><li>브랜치 rule 설정</li><li>.github meta setting</li><li>ci &amp; cd setting (너무 공수가 많이든다.)</li></ul></li><li>공통 모듈과 환경설정들을 공유할 수 없다.</li></ul><h2>어떻게 문제를 해결할 수 있을까?</h2><p>위에 서술한 단점들을 해결하기 위해서 microfrontends에서는 monorepo를 도입하기 시작했습니다. (회사 웹뷰의 경우 모든 프로젝트들을 각기 다른 레포로 관리하는 multirepo 방식을 사용하고 있습니다.)</p><p>yarn workspace와 lerna를 통해 여러 서비스들을 monorepo로 관리가 가능한데, 이렇게 했을 때 환경설정과 공통 컴포넌트 &amp; 함수들을 상위에 정의함으로써 공유가 가능하고, 서비스들은 packages를 통해 msa로 관리가 가능해졌습니다.</p><h3>그렇다면 이제, 웹뷰 프로젝트에 적용해볼까?</h3><p>위에서도 설명했듯이 웹뷰 프로젝트들은 두개의 프레임워크를 사용하고 있다고 했습니다. 이렇게 서비스들이 프레임워크를 다르게 사용하니 공통 컴포넌트를 사용할 수도 없고, 환경설정도 모두 다르게 셋팅 해줘야하는 문제 발생했습니다. 모노레포의 장점을 전혀 살리지 못하는거죠.</p><p>그래서 모노레포로 서비스들을 마이그레이션하는 작업을 중단하게 되었습니다. 😭</p><h3>이대로 끝인가?</h3><p>결국 모노레포로 마이그레이션은 시키지 못했지만, 그래도 할 수 있는 작업들이 있습니다. (사실 vue로 되어있는 A 프로젝트를 react로 변환하면 되지만.. 너무 공수가 큽니다 ㅠ)</p><p>현재 진행중인 디자인 시스템을 활용해 공통 컴포넌트를 모듈로 만들어 npm에 등록시키고 react를 사용하는 곳에서 가져다 사용하는 방법으로 말이죠. (eslint도 npm에 등록)</p><p>한꺼번에 많은 변화를 만들어내지는 못하겠지만 조금씩 조금씩 고쳐가고 개선해 나가면, 노력은 적게들고 개발을 빠르게 할 수 있게 될 것 같습니다.</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[재사용 가능한 컴포넌트]]></title>
        <id>재사용 가능한 컴포넌트</id>
        <link href="https://kooku0.gihub.io/blog/재사용-가능한-컴포넌트"/>
        <updated>2021-10-23T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[프론트엔드에서 화면을 구현하기 많은 컴포넌트들이 만들고, 그 컴포넌트들을 조합하여 화면을 구성하게 됩니다.\]]></summary>
        <content type="html"><![CDATA[<p>프론트엔드에서 화면을 구현하기 많은 컴포넌트들이 만들고, 그 컴포넌트들을 조합하여 화면을 구성하게 됩니다.\
너무 많은 컴포넌트들이 만들어지게 되면 유지보수가 힘들어지게되고 중복된 코드가 많아지기에 재사용 가능한 컴포넌트를 만드는게 매우 중요한 일이 되었습니다.</p><h2>추상화를 해라</h2><p>예를들어 로그인 페이지에서의 버튼과 웹뷰에서 하단 Floating 버튼을 만든다고 했을 때 둘은 비슷하지만 다른 컴포넌트입니다.
둘다 버튼이긴 하지만 로그인 페이지에서의 버튼은 단순한 버튼이고, Floating 버튼은 floating 스타일도 추가되고 버튼 밖을 하나의 wrapper가 있을 겁니다.
이럴 때 추상화가 필요합니다. Button이라는 주요한 기능과 스타일을 모아 Base Component를 만들고 Floating 버튼에서는 이 Base Button을 바탕으로 다른 스타일을 조합해서 사용할 수 있습니다.
이처럼 Base Button Component를 바탕으로 파생적으로 많은 컴포넌트를 만들 수 있습니다. 객체지향에서 말하는 개방폐쇄원칙입니다.</p><h2>Inversion Of Control</h2><p>웹뷰에서 사용할 Floating 버튼을 만들었고 이 버튼을 다른 페이지에서도 사용하고 싶습니다. 그리고 버튼을 눌렸을 때의 동작도 달랐으면 좋겠습니다.
만약에 Floating 버튼 컴포넌트안에 button click handler가 들어있다면 해당 컴포넌트를 재사용할 수 없습니다.
그래서 Floating 버튼을 사용하는 페이지에서 handler를 만들고 이를 props로 Floating 버튼으로 내려주면 해결이 가능한데 이를 IOC (Inversion Of Control)이라고 부릅니다.</p><h3>무조건적인 IOC는 유지보수에 취약해진다.</h3><p>sns 공유를 할 수 있는 공유하기 버튼이 만들고 공유하기 버튼이 여러 페이지에서 사용된다고 했을 때 IOC를 사용하게 되면 공유하기 버튼을 사용하는 페이지에 모두 handler를 만들어줘야 합니다.
이런 경우에는 IOC를 사용하기 보다 공유하기 버튼 컴포넌트를 따로 만들어 handler 혹은 비즈니스 로직을 컴포넌트안에 포함시키는게 유지보수하기 쉽습니다. 흔히 말하는 캡슐화를 사용하게 되는거죠.
공유하기 버튼은 항상 같은 같은 기능을 할꺼고 컴포넌트를 사용하는 개발자 입장에서는 공유하기에 관련된 로직이 어떤지 고민하지 않고 사용하게 될겁니다.\
자주사용하는, 변경이 많이 발생하지 않을 컴포넌트는 캡슐화를 시키자.</p><h2>스타일도 추상화 시켜라</h2><p>버튼을 공통 컴포넌트로 만든다고 생각할 때 가장 먼저 떠오르는 버튼의 기능은 click event, 버튼 text, type 정도가 될겁니다.</p><pre><code class="language-jsx">function Button({ children, ...rest }) {
  return (
    &lt;button type=&quot;button&quot; {...rest}&gt;
      {children}
    &lt;/button&gt;
  );
}
</code></pre><p>하지만 여기에 스타일을 추가해보겠습니다.
노란색 테두리에 배경은 흰색이고 글자색은 보라색, 포인터가 올려졌을 때 버튼의 배경은 회색이 되어야한다.
단순하다고 생각한 버튼이 매우 복잡한 버튼이 되었습니다.
이처럼 스타일이 컴포넌트와 합쳐지게 되면 컴포넌트가 매우 복잡해집니다.</p><p>이러한 문제점을 해결하기 위해 탄생한 것 중 하나가 styled-component입니다.
styled-component의 핵심은 스타일을 css 문서가 아닌 컴포넌트 레벨로 추상화하는 것 입니다.
(사실은 매우 많은 논란이 있는 주제이긴합니다.)</p><p>styled-component를 이용해서 스타일도 추상화해봅시다.</p><pre><code class="language-jsx">const StyledButton = styled.button`
  border-radius: 0.25rem;
  font-size: 1.25rem;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border: 1px solid lightgray;

  color: ${(props) =&gt; props.color || &quot;gray&quot;};
  background-color: ${(props) =&gt; props.background || &quot;white&quot;};
`;

function Button({ children, ...rest }) {
  return (
    &lt;StyledButton type=&quot;button&quot; {...rest}&gt;
      {children}
    &lt;/StyledButton&gt;
  );
}
</code></pre><p>버튼이 가지고 있는 기본적인 스타일을 추상화시키고, 변경이 많이 일어나는 color와 backgroundColor를 props로 받게 만들었습니다.</p><p><img src="../images/reusable-component.png"/></p><p>그림과 같은 버튼을 구현하는건 세개의 컴포넌트를 만드는게 아닌 추상화 시킨 하나의 버튼 컴포넌트만으로 가능해졌습니다.</p><pre><code class="language-jsx">&lt;Button&gt;Default Button&lt;/Button&gt;
&lt;Button color=&quot;green&quot; background=&quot;pink&quot;&gt;Green Button&lt;/Button&gt;
&lt;Button color=&quot;white&quot; background=&quot;blue&quot; disabled&gt;Primary Button&lt;/Button&gt;
</code></pre>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021년 10월 둘째 주 회고]]></title>
        <id>2021년 10월 둘째 주 회고</id>
        <link href="https://kooku0.gihub.io/blog/2021년-10월-둘째-주-회고"/>
        <updated>2021-10-18T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Facts (사실, 객관)]]></summary>
        <content type="html"><![CDATA[<h2>Facts (사실, 객관)</h2><ul><li>개인 프로젝트 시작: 프로젝트 셋팅</li></ul><h2>Feeling (느낌, 주관)</h2><ul><li>개인 프로젝트를 시작했다. cra와 TypeScript를 사용하지 않고 webpack 설정을 직접만지면서 하나씩 셋팅했는데 webpack을 셋팅하는 즐거움이 있었다.</li><li>코드숨에서는 e2e test를 codeceptjs를 이용해서 진행했었는데 codeceptjs를 한 번도 공부하거나 배운적은 없지만 이번 프로젝트를 하면서 조금식 공부해 볼 예정이다.</li></ul><h2>Finding (배운 점, 교훈)</h2><ul><li>codeceptjs에서는 web driver를 선택해서 사용할 수 있다. 코드숨에서는 puppeteer를 사용했었는데, 예전 구글에 있던 puppeteer 팀이 마이크로소프트사로 팀 전체가 옮겨가서 잘 운영되고 있지는 않다고 들었다, 현재는 그 팀이 playwright를 개발하여 운영하고 있다는 걸로 알고있다.</li><li>webpack setting을 하다가 <a href="https://github.com/pmmmwh/react-refresh-webpack-plugin">react-refresh-webpack-plugin</a>에 대해 알게 되었다. React 에서 코드 수정이 발생했을 때 변경을 감지해 data를 건드리거나 refresh 하는게 아니라 해당 컴포넌트만 새로 렌더링하는건데 webpack에서 사용하면 매우 유용할 것 같다.</li></ul><h2>Affirmation (자기 선언)</h2><ul><li>코드숨 과제를 처음부터 tdd로 개발한다고 생각하고 차근차근 해보려고 한다.</li></ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021년 10월 첫째 주 회고]]></title>
        <id>2021년 10월 첫째 주 회고</id>
        <link href="https://kooku0.gihub.io/blog/2021년-10월-첫째-주-회고"/>
        <updated>2021-10-07T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Facts (사실, 객관)]]></summary>
        <content type="html"><![CDATA[<h2>Facts (사실, 객관)</h2><ul><li>코드숨 과제: emotion 다루기, redux-toolkit 다루기</li></ul><h2>Feeling (느낌, 주관)</h2><ul><li>Redux-toolkit 을 사용했을 때 redux를 정말 쉽게 사용할 수 있어 좋아보였다.</li><li>emotion을 사용해봤는데 사용법은 쉽게 익혔으나, 어떻게 해야 잘 사용할 수 있을지 고민을 해볼 필요가 있었던 것 같다. 어떡해야 잘 사용할까..</li><li>이번 과제에서는 pr에서 css-in-js에 대해 의문을 트레이너님께 물어보는 형식으로 진행했는데 궁금즘을 많이 해소했다.</li></ul><h2>Finding (배운 점, 교훈)</h2><ul><li>Css-in-js 도 테스트 코드를 작성하는가?<ul><li>스타일 컴포넌트는 디자인 쪽에 가깝기 때문에 디자인 시스템을 구축하여 스토리북을 이용해 관리한다.</li><li>찾아보니 <a href="https://www.chromatic.com/">chromatic</a>을 이용하여 visual test를 할 수 있다고 한다.</li></ul></li><li>Css-in-js도 스타일이기에 css 처럼 파일로 분리해야하지 않을까? view와 business-logic을 container와 분리시킨 것 처럼<ul><li>CSS in JS 를 사용하는 이유는 컴포넌트내에서 스타일을 처리해주기 때문에 독립적으로 관리가 가능하고, 따로 CSS 파일을 두지 않아도 되기 때문에 유지보수하기가 좋다. 따라서 보통 재사용되는 스타일만 따로 분리해서 사용한다. 재사용되지 않는 스타일 컴포넌트는 리액트 컴포넌트 파일 안에 정의하고 사용한다.</li></ul></li></ul><h2>Affirmation (자기 선언)</h2><ul><li>Css-in-js 를 어떻게 해야 잘 사용할지 고민을 해보자. storybook도 공부해보면 재미있을 것 같다.</li></ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021년 9월 넷째 주 회고]]></title>
        <id>2021년 9월 넷째 주 회고</id>
        <link href="https://kooku0.gihub.io/blog/2021년-9월-넷째-주-회고"/>
        <updated>2021-10-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Facts (사실, 객관)]]></summary>
        <content type="html"><![CDATA[<h2>Facts (사실, 객관)</h2><ul><li>코드숨 과제: 로그인</li></ul><h2>Feeling (느낌, 주관)</h2><ul><li>지금까지 배운내용을 바탕으로 다른 프로젝트에서도 테스트를 원할히 작성할 수 있을 것 같다는 자신감이 생겼다.</li><li>TDD.. 여전히 어렵지만 그래도 흉내는 낼 수 있게 되었다.</li></ul><h2>Finding (배운 점, 교훈)</h2><ul><li>Given 라이브러리를 통해 쉽게 테스트를 할 수 있다. useSelector의 store 데이터 mocking을 lazy하게 처리한다.</li></ul><h2>Affirmation (자기 선언)</h2><ul><li>이번주 화이팅!</li></ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021년 9월 셋째 주 회고]]></title>
        <id>2021년 9월 셋째 주 회고</id>
        <link href="https://kooku0.gihub.io/blog/2021년-9월-셋째-주-회고"/>
        <updated>2021-09-19T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Facts (사실, 객관)]]></summary>
        <content type="html"><![CDATA[<h3>Facts (사실, 객관)</h3><ul><li>코드숨 과제: 레스토랑 상세 구현하기</li><li>Posting-review 스터디 끝</li></ul><h3>Feeling (느낌, 주관)</h3><ul><li>Test 코드 작성할 때 여러 라이브러리들을 mocking하는 방법들이 어려웠다. Mocking 하는 방법이나 원리를 익혀봐야할 것 같다.</li><li>저번주에 작성하고 강의로 배운 것과 이번주차에서 주어진 작성된 코드를 비교해봤을 때 차이가 많이 나서 당황했다. 작성한 코드의 부실함이 돋보였던 것 같다.</li><li>이번 주차 강의를 들으면서 test 코드 작성법 뿐 아니라 코드 작성법까지 익혔던 것 같다. 항상 해당 컴포넌트에서 useParams나 useHistory 썼었는데 상위에서 내려주게 함으로써 test도 용이하게 작성하는게 인상깊었다.</li><li>개인적으로 posting-review 스터디를 10주간 진행했는데, 오늘 마지막 회고를 하였다. 이 스터디는 “공부한 내용들을 정리해야겠다”라고 생각만 하고 안해서 등록한 스터디인데, 확실히 공부한 내용을 글로 정리해보는게 머릿속에 오래 남기도하고 도움이 많이 되었다. (글로 정리하면 말로 설명할 때 잘 설명할 수 있었다)</li></ul><h3>Finding (배운 점, 교훈)</h3><ul><li>Redux thunk 를 mocking하기 위해 <code>redux-mock-store</code> 를 사용할 수 있다.</li><li>mocking을 하고 다른 testcase에서 사용될 수 있기에 <code>mock.clear</code>를 해주는게 항상 필요하다.</li></ul><h3>Affirmation (자기 선언)</h3><ul><li>연휴동안 지금까 작성한 코드들을 처음부터 작성해보며 익히.</li></ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021년 9월 둘째 주 회고]]></title>
        <id>2021년 9월 둘째 주 회고</id>
        <link href="https://kooku0.gihub.io/blog/2021년-9월-둘째-주-회고"/>
        <updated>2021-09-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Facts (사실, 객관)]]></summary>
        <content type="html"><![CDATA[<h2>Facts (사실, 객관)</h2><ul><li>코드숨 과제 1: 레스토랑 조회 구현하기</li><li>이번과제는 제대로 수행하지 못했다.</li></ul><h2>Feeling (느낌, 주관)</h2><ul><li>이전 주차와 마찬가지로 TDD 개발방법론으로 개발을 진행했으나 많이 어려웠었다. 그래서 TDD로 개발하려고 하면서 고민했던 부분들을 모아 질문을 했고, 트레이너 님의 답변으로 TDD에 대해 조금은 알게 되었다.</li><li>테스트 주도개발(TDD) 책을 읽어봐야 TDD에 대해 확실히 알 것 같다!!</li></ul><h2>Finding (배운 점, 교훈)</h2><ul><li>TDD를 작은 사이클로 진행하자. 그래야 변경하기도 쉽고 변경해야할 부분도 잘 보인다.</li><li>컴포넌트 분리는 기능을 모두 구현한 다음에 진행해보자.</li><li>처음부터 완벽하게 만들려고 하지말고, 지금 구조에서 최선을 다하자.</li><li><img src="../images/codesoom-w5-code-review.png"/></li></ul><h2>Affirmation (자기 선언)</h2><ul><li>추석이 끝나고 테스트 주도 개발 (TDD) 책 꼭 사서 읽어보자!</li><li>이번주차는 처음부터 끝까지 TDD로 제대로 구현해보자!💪</li></ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021년 9월 첫째 주 회고]]></title>
        <id>2021년 9월 첫째 주 회고</id>
        <link href="https://kooku0.gihub.io/blog/2021년-9월-첫째-주-회고"/>
        <updated>2021-09-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Facts (사실, 객관)]]></summary>
        <content type="html"><![CDATA[<h2>Facts (사실, 객관)</h2><ul><li>코드숨 과제 1: To-Do 리스트 Redux를 사용해 리팩터링 하기</li><li>코드숨 과제 2: 레스토랑 정보 확인 및 예약 시스템 구축하기</li><li>HTTP3 간단히 공부</li></ul><h2>Feeling (느낌, 주관)</h2><ul><li>이전 주차에서는 redux 테스트코드 짜는걸 처음접해봐서 재미있기도 했고 이제 테스트코드 짜는걸 조금 알겠다 싶었다. 그런데 이전 과제를 보지않고 다시 테스트 코드를 짜려고 하니 어떻게 테스트 코드를 짰었는지 까먹어서 많이 헤맸다… 결국 이전에 작성한 코드를 살짝 보면서 코딩을 했는데, 왜 테스트 코드를 반복해서 짜보라고 하셨는지 이해가 되었다.</li><li>처음부터 끝까지 TDD로 구현을 하려고 시도했는데.. 마음처럼 되지 않았다. 구현부터 진행하는게 익숙해져서 테스트코드를 먼저 짠다는게 쉽지 않았다. 첫 pr 후 피드백 받은 내용은 미리 예상해서 컴포넌트를 만들지 말고 테스트 -&gt; 구현 -&gt; 리펙터링의 과정을 거쳐 컴포넌트를 나누라고 하셨다. 그래서 프로젝트 코드를 다지우고 App 파일에 먼저 구현하고 진행하려고 했는데 쉽지 않았다. 어떻게 짜야할지 머릿속에 조금은 그려지니 TDD로 개발을 해야하는데 이미 구조를 짜놓고 개발을 시작해버렸다… 이전의 습관을 버리고 TDD로 개발을 하기 위해 계속 시도해봐야 겠다.</li><li>이번주에 짬내서 HTTP3에 대해 공부를 했는데, 전세계 웹사이트의 21.3%가 이미 http3를 사용하고 있다고 한다. 아직 http3는 계획단계로 알고 있었는데 크롬에서는 2020년 4월부터 정식으로 지원했다고 하니… 깜짝 놀랐다.</li></ul><h2>Findings (배운 점, 교훈)</h2><ul><li>TDD는 테스트 -&gt; 구현 -&gt; 리펙터링의 사이클을 가진다. 미리 구조를 생각하고 개발을 하지말고, 리펙터링의 과정 때 컴포넌트를 나누어야 한다.</li><li>HTTP/3은 UDP기반 QUIC 프로토콜을 사용한다. 3-way-handshack가 없으니 연결속도가 TCP에 비해 50% 빠르다. 이에 CDN 서비스 제공업체가 가장먼저 HTTP/3을 도입했는데 초당 요청을 처리하는 횟수도 50% 이상 높아졌다고 한다.</li></ul><h2>Affirmation (자기 선언)</h2><ul><li>매일매일 꾸준하게 공부하자. 공부는 복리로 나를 성장시킨다.</li><li>이전의 습관을 버리고 TDD로 생각하는 법을 익히자!</li></ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021년 8월 넷째 주 회고]]></title>
        <id>2021년 8월 넷째 주 회고</id>
        <link href="https://kooku0.gihub.io/blog/2021년-8월-넷째-주-회고"/>
        <updated>2021-08-30T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Facts (사실, 객관)]]></summary>
        <content type="html"><![CDATA[<h2>Facts (사실, 객관)</h2><ul><li>처음으로 테스트 코드를 작성해보았다. (TDD, BDD)</li><li>팩토리 패턴과 빌더 패턴에 대해 공부했다.</li></ul><h2>Feelings (느낌, 주관)</h2><ul><li>테스트코드의 중요성은 어느정도 알고 있었기에 조금씩 공부는 했으나 BDD 관점으로 사용해본적은 처음이어서 많이 헤매었다.</li><li>TDD 테스트 주도 개발 책을 읽어봐야겠다는 생각이 들었다.</li><li>프론트엔드에서도 data 상태에 따라 스타일, 텍스트, 행동 등이 나뉘는 경우가 있는데 이럴 때 팩토리 패턴을 사용하면 훨씬 편할 것 같다는 생각이 들었다.</li></ul><h2>Findings (배운 점, 교훈)</h2><table><thead><tr><th align="center">키워드</th><th align="center">설명</th></tr></thead><tbody><tr><td align="center">Describe</td><td align="center">설명할 테스트 대상을 명시한다.</td></tr><tr><td align="center">Context</td><td align="center">테스트 대상이 놓인 상황을 설명한다.</td></tr><tr><td align="center">It</td><td align="center">테스트 대상의 기대되는 행동을 명시한다.</td></tr></tbody></table><ul><li>BDD로 테스트코드를 작성하면 시나리오 대로 케이스를 작성할 수 있어 놓치는 부분이나 에러케이스들을 모두 확인할 수 있다.</li><li>테스트 코드를 짜게되면 유지보수할 때 와 리펙토링 할 때 side-effect를 염려하지 않고 개발할 수 있다.</li><li>팩토리 패턴은 파생클래스(자식클래스)들을 switch case를 이용해 인스턴스를 생성해준다.</li><li>빌더 패턴은 생성자에 모든 값을 넣어주지 않고 체이닝등을 통해 인스턴스를 빌드(생성)한다.</li></ul><h2>Affirmation(자기 선언)</h2><ul><li>지금 부터 작성하는 코드들은 모두 TDD, BDD를 적용하자!</li><li>다른 패턴들도 공부해보고 어떤 문제 상황일 때 적용할 수 있을지 고민해보자.</li></ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021년 8월 셋째 주 회고]]></title>
        <id>2021년 8월 셋째 주 회고</id>
        <link href="https://kooku0.gihub.io/blog/2021년-8월-셋째-주-회고"/>
        <updated>2021-08-22T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Facts (사실, 객관)]]></summary>
        <content type="html"><![CDATA[<h2>Facts (사실, 객관)</h2><ul><li>코드숨 2주차 과제를 끝냈다.</li><li>오브젝트 책 3장, 4장 읽었다.</li><li>리펙토링 2판 6.7장 까지 읽었다.</li><li>HTTP Caching에 대해 공부했다.</li></ul><h2>Feelings (느낌, 주관)</h2><p>스터디를 여러개 하고 있어 열심히 살고 있다는 생각이 드는 것 같다. 버거운 느낌이 들어 몇 개는 하지말까 라는 생각도 들었지만 스터디에서 작은 것들이라도 얻는게 있어 포기하기에는 너무 아까운 것 같다. 시작한 이상 열심히 해보려고 한다.</p><p>오브젝트 책 3장을 정말 재미있게 읽었다. 그리고 내가 지금까지 객체를 잘 못 만들고 있었다는 것을 알게되었고 남은 부분도 빨리 읽고 싶어졌다.</p><p>아 그리고 최근에 객체지향에 관심을 많이 가져 다른 부분을 공부하지 못했는데 JS prototype에 대해 조금 더 깊게 공부해보려고 한다.</p><h2>Findings (배운 점)</h2><p>HTTP Caching에 대해 공부했는데, 왜 이걸 이제야 공부했지 라는 생각이 들었다. <code>cache-control</code>과 200(from disk, from,memory) 304 등...알고나니 눈에 많은 것들이 보이기 시작했다.\
객체는 데이터중심이 아니라 행동중심으로 설계되어야한다.\
리펙토링 책은 1~4장 때는 배울게 많았는데(리펙토링을 해야하는 이유와 했을 때 좋아지는 걸 코드로 보여준다.) 5장부터는 리펙토링 방법들을 예시로 보여주기에 재미는 많이 없었다.</p><h2>Affirmation (자기 선언)</h2><p>후회하지 않도록 열심히 해보자.\
내 실력에 자신감이 생기도록.</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP Caching]]></title>
        <id>HTTP Caching</id>
        <link href="https://kooku0.gihub.io/blog/http-caching"/>
        <updated>2021-08-22T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[https://developer.mozilla.org/ko/docs/Web/HTTP/Caching 글을 정리했습니다.]]></summary>
        <content type="html"><![CDATA[<blockquote><p><a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Caching">https://developer.mozilla.org/ko/docs/Web/HTTP/Caching</a> 글을 정리했습니다.</p></blockquote><p>빠른 웹사이트 로딩(First load times)을 위한 방법들은 여러가지가 있습니다.</p><ul><li>WebCache</li><li>Code Compress</li><li>Lazy loading</li><li>Critical Rendering Path</li><li>...</li></ul><p>이중 Http Caching에 대해 정리해보았습니다.
HTTP 캐시들은 일반적으로 <code>GET</code>에 대한 응답만을 캐싱합니다. <code>GET</code>이 REST적 의미로 가져오다이기 때문에, 가져온 데이터를 저장해두고 두고두고 사용합니다. 일반적으로 200(성공), 301(다른 주소로 이동 후 가져옴), 404(가져올게 없음) 상태 코드로 온 응답을 캐싱합니다.</p><h2><code>Cache-control</code> 헤더</h2><p>캐시 정책들을 정의할 때 쓰는 헤더입니다.</p><h3>캐시하지 않음</h3><p>클라이언트 요청 혹은 응답에 대해 어떤 것도 저장하지 않습니다.</p><pre><code>Cache-Control: no-store
</code></pre><h3>캐시하지만 재검증</h3><p>캐시를 사용하기 전에 서버에게 이 캐시 진짜 써도 되는지 물어봅니다.</p><pre><code>Cache-Control: no-cache
</code></pre><h3>사설 캐시와 공개 캐시</h3><p>&quot;public&quot;은 어떤 캐시(CDN)에 의해서든지 캐시되어도 좋다는 뜻입니다.</p><p>&quot;private&quot;는 공유 캐시에 저장되어서는 안된다는 뜻입니다.(브라우저)</p><pre><code>Cache-Control: private
Cache-Control: public
</code></pre><h3>만료</h3><p><strong>max-age</strong>\
리소스가 유효하다고 판단되는 최대 시간을 말합니다. 요청 시간에 상대적이며, <code>Expires</code>가 설정되어 있어도 그보다 우선합니다. 변경되지 않을 파일에 대해 긴시간 캐싱할 수 있습니다. 예를들어 이미지, CSS 파일, JS파일과 같은 정적 파일들입니다.</p><pre><code>Cache-Control: max-age=3153600
</code></pre><p><strong>Age</strong>\
Age 헤더는 캐시 응답 때 나타나는데, max-age 시간 내에서 얼마나 흘렸는지 초 단위로 알려줍니다.
max-age를 1시간으로 설정한 후 1분이 지나면</p><pre><code>Cache-Control: max-age=3600
Age: 60
</code></pre><p>이 캐시 응답 헤더에 포함됩니다.</p><p><strong>Expires</strong>\
Cache-Control과 별개로 응답에 Expires라는 헤더를 줄 수도 있습니다.\
response contents가 언제 만료되는지를 나타내며, Cache-Control의 max-age가 있는 경우 이 헤더는 무시됩니다.</p><h3>검증</h3><p>만료된 캐시면 서버에서 확인을 받아야 합니다.</p><pre><code>Cache-Control: must-revalidate
</code></pre><h2>유효성(Freshness)</h2><p>리소스가 캐시에 저장되고 나면 이론적으로는 영원히 캐시에 의해 서비스될 수 있습니다. 하지만 캐시는 유한한 저장공간을 가지므로 주기적으로 스토리지에서 제거되는데 이를 캐시축출(cache eviction)이라고 부릅니다.</p><p>만료시간 이전의 리소스는 유효하다(fresh)라고 부르고, 만료시간 이후의 리소스는 실효(stale)됐다고 이야기 합니다.</p><p>캐시가 실효된 리소스에 대해 요청을 받았을 때(max-age 초과, no-cache, must-revalidate) 리소스가 아직 유효한지 아닌지를 확인하고, 유효하다면 서버는 요청된 리소스 본문을 전송하지 않고 304(Not Modified)헤더를 돌려보내 대역폭을 절약합니다.</p><h2>캐시 검증</h2><p>캐시된 리소스의 만료시간이 가까워지면, 리소스를 검증하거나 다시 불러오게 됩니다.</p><h3>ETags</h3><p>HTTP 컨텐츠가 바뀌였는지를 검사할 수 있는 태그입니다. 같은 주소의 자원이더라도 컨텐츠가 달라졌다면 ETag가 다릅니다.</p><h2>Example</h2><h3>200 (from memory cache)(from disk cache)</h3><p>max-age가 거의 무한이고, age도 많이 흐르지 않았기에 유효한 리소스라 memory에 있는 리소스(캐시된 리소스)를 그대로 사용한다.</p><h4>memory cache vs disk cache</h4><p>브라우저가 캐시를 사용할 때 memory에 저장되어 있는 캐시를 사용하거나 disk에 저장된 캐시를 사용할 수 있다. memory는 최근에 사용했다면 있을 것이고 그렇지않다면 disk에 있을 것이다.</p><p>disk가 memory보다 데이터를 가져오는 속도가 느리기에 당연히 속도 차이가 난다. (memory: 0ms, disk: 3ms)</p><p><img src="../images/cache-memory-disk.png" alt="cache-memory-disk"/></p><pre><code>[General]
Request URL: https://abcd.com/a.js
Request Method: GET
Status Code: 200  (from memory cache)
Remote Address: 54.192.175.42:443
Referrer Policy: strict-origin-when-cross-origin

[Response Headers]
accept-ranges: bytes
age: 34710
cache-control: public, max-age=31536000, immutable
content-encoding: gzip
content-type: application/javascript; charset=UTF-8
date: Thu, 19 Aug 2021 04:48:26 GMT
etag: W/&quot;1ffd7-17b5cba00f8&quot;
last-modified: Thu, 19 Aug 2021 04:44:59 GMT
server: CloudFront
vary: Accept-Encoding
via: 1.1 f681dbff28feeb503e3ad2f4be29ead3.cloudfront.net (CloudFront)
x-amz-cf-id: Lcm5rnqwYZiSzQT9XETch79qqg6XHOpATvBUWVnefT4VlI2CNs9Veg==
x-amz-cf-pop: ICN55-C1
x-cache: Hit from cloudfront
</code></pre><h3>304 (Not Modified)</h3><p>max-age=0 이라 컨텐츠가 유효한지 sever로 재검증을 하게 된다. 하지만 CloudFront에 저장된 리소스 ETag 일치하므로 서버의 리소스가 갱신되지 않았다는 것을 알 수 있고 304 status code를 보내어 브라우저에 저장된 캐시를 재사용한다.</p><pre><code>[General]
Request URL: https://abcd.com/a.png
Request Method: GET
Status Code: 304
Remote Address: 54.192.175.42:443
Referrer Policy: strict-origin-when-cross-origin

[Response Headers]
accept-ranges: bytes
cache-control: public, max-age=0
date: Thu, 19 Aug 2021 14:27:09 GMT
etag: W/&quot;82cc92-17b5cb83408&quot;
last-modified: Thu, 19 Aug 2021 04:43:01 GMT
server: CloudFront
via: 1.1 f681dbff28feeb503e3ad2f4be29ead3.cloudfront.net (CloudFront)
x-amz-cf-id: OgTtmM59-0C7A8KfeXsoiUWBrAduM1CHuVZnjHNFuFzPy6BgS7Datg==
x-amz-cf-pop: ICN55-C1
x-cache: Miss from cloudfront
</code></pre><h2>Reference</h2><ul><li><a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Caching">https://developer.mozilla.org/ko/docs/Web/HTTP/Caching</a></li></ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2021년 8월 둘째 주 회고]]></title>
        <id>2021년 8월 둘째 주 회고</id>
        <link href="https://kooku0.gihub.io/blog/2021년-8월-둘째-주-회고"/>
        <updated>2021-08-16T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[최근에 개발을 하며 누군가에게 피드백을 받아보고 싶다는 생각이 많이 들었다. 나의 실력이 제자리 걸음을 하고 있다는 생각도 들었고, 책에서 이야기하는 이론을 바탕으로 실제 코드를 작성했을 때 단지 흉내만 내고 있는지, 개발 철학을 반영하여 개발하고 있는지 궁금했다.]]></summary>
        <content type="html"><![CDATA[<p>최근에 개발을 하며 누군가에게 피드백을 받아보고 싶다는 생각이 많이 들었다. 나의 실력이 제자리 걸음을 하고 있다는 생각도 들었고, 책에서 이야기하는 이론을 바탕으로 실제 코드를 작성했을 때 단지 흉내만 내고 있는지, 개발 철학을 반영하여 개발하고 있는지 궁금했다.
이러한 상황에 코드숨은 나에게 좋은 기회였고, 코드숨 1주차가 지나갔다.</p><p>첫 과제는 어렵지 않았다. (2번 과제는 제대로 수행하지 못했다.ㅠㅠ)\
빠르게 완료해서 제출을 했다. 그런데 이렇게 이 과제를 끝내기에는 너무 아쉬웠다. 책에서 읽었던 내용을 이 간단한 코드에 적용해보고 싶다는 생각이 들어 함수를 쪼개고 side-effect를 줄이고, 유연하게 만들고자 시도를 하기 시작했다.
이런 시도를 하면서 이전 코드보다 훨씬 더 많은 피드백을 받을 수 있었고 나의 부족한 부분을 찾아가는 과정이 되었다.</p><h3>부족했던 것들</h3><ul><li>여러가지 이유로 과제에 시간을 많이 쏟지 못했다. \
: 하루에 1시간씩은 과제에 투자하자.</li><li>익숙함에 기본적인 것들을 지나치는 경우가 있었다. (반복되는 로직을 그대로 사용등) \
: 익숙함에 길들여져 기본을 무시하지는 말자.</li></ul><h3>앞으로도 유지해야할 것들</h3><ul><li>많은 시도를 해보자. 많은 시도를 했을 때 많은 피드백을 들을 수 있고, 그게 나를 성장시킨다.</li></ul><h3>배운 것</h3><ul><li>코드는 사용하는 쪽을 최우선으로 고려하여 작성하자. 좋은 설계는 변화에 대응하기 좋은 상태를 만들어 낸다.</li><li>관심사의 분리: 경계를 잘 나누어야한다. (아직 경계를 발견해서 나누는 것이 익숙하지 않은데 이건 계속 연습해봐야할 것 같다.)</li><li>guard clauses (if else switch는 해롭다.)\
: 클린코드를 읽어보자 💪</li></ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React가 Class Component에서 Functional Component로 패러다임을 전환한 이유]]></title>
        <id>React가 Class Component에서 Functional Component로 패러다임을 전환한 이유</id>
        <link href="https://kooku0.gihub.io/blog/react가-class-component에서-functional-component로-패러다임을-전환한-이유"/>
        <updated>2021-08-06T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[왜 Functional Component가 탄생했을까?]]></summary>
        <content type="html"><![CDATA[<p>왜 Functional Component가 탄생했을까?</p><h2>1. Reusing logic</h2><blockquote><p>you often end up with this wrapper hell</p></blockquote><p>React 개발자들은 code 재사용을 위해 <code>Higher-order components</code>, <code>Render props</code> 두 메인 패턴을 사용하고 있습니다.</p><p>하지만 이런 패턴의 사용은 컴포넌트의 재구성을 강요하며, 코드의 추적을 어렵게 만듭니다. 이런 패턴들을 사용하게 되면 React 개발자 도구에서 providers, hoc, render props 그리고 다른 추상화 레이어로 둘러싸인 &quot;레퍼 지옥(wrapper hell)&quot;을 보게 됩니다.</p><p>Hook을 사용하면 컴포넌트로 부터 상태관련 로직을 추상화 할 수 있습니다. 이를 통해 독립적인 테스트와 재사용이 가능합니다. <strong>Hook은 계층의 변화없이 상태 관련 로직을 재사용할 수 있도록 도와줍니다.</strong> 이것은 많은 컴포넌트들 사이에서 Hook을 공유하기 쉽게 만들어 줍니다.</p><p>상태로직의 재사용의 경우 Vue2에서는 Mixin을 사용하기에 React에서도 Mixin을 만들어 Class Component에 붙여 사용하면 되지 않느냐고 할 수 있겠지만, React 팀은 Mixin의 사용을 예전부터 극도로 싫어했습니다.</p><h3>mixin을 싫어하는 이유</h3><p><a href="https://ko.reactjs.org/blog/2016/07/13/mixins-considered-harmful.html">Mixins Considered Harmful - React Blog</a></p><h2>2. Giant components</h2><blockquote><p>logic split across different life cycles</p></blockquote><p>life-cycle method를 파악하기 힘들어 컴포넌트가 unmounted 될 때 리소스를 clean up 하는 것을 잊거나 life-cycle method와 관련없는 로직들이 섞여들어가기도 쉽습니다.
또한 life-cycle 관련 로직들이 한 공간안에 묶여 있기 때문에 컴포넌트들을 작게 분리하기 힘들고 테스트하기도 어렵습니다.</p><p>이런 문제를 해결하기 위해 life-cycle method를 기반으로 쪼개는 것 보다는, <strong>hook을 통해 서로 비슷한 것을 하는 작은 함수의 묶음으로 컴포넌트를 나누는 방법을 사용할 수 있게 만들었습니다.</strong></p><h2>3. Confusing classes</h2><blockquote><p>difficult for both humans and machines</p></blockquote><h3>Hard for humans</h3><p>Class Component를 사용할 때 이벤트 핸들러가 등록되는 방법을 정확히 파악해야 했으며, JavaScript의 <code>this</code>가 어떻게 동작하는지도 알아야만 했습니다.</p><p>React 내의 함수와 Class 컴포넌트의 구별, 각 요소의 사용 타이밍 등은 숙련된 React 개발자 사이에서도 의견이 일치하지 않습니다. (많은 개발자들이 binding하는 방식과 class에서 동작하는 작업들에 혼란을 많이 느꼈다고 react-core 팀에 많이 호소를 했다고 합니다.)</p><h3>Hard for machines</h3><p>React App을 빌드해서 manified component file들을 보게된다면 manified된 method names과 여전히 manified되지 않은 method name들을 볼 수 있습니다. manified되지 않은 method name이 있다는 것은 사용하지 않는 method가 있더라도 삭제되지 않는 다는 것을 이야기하고, 이는 컴파일시간이 오래걸리는 것을 말해줍니다.(functional component에서는 사용하지 않는 inner function들이 자동삭제) 이는 class가 hot reloading을 안정적으로 구현하기 어렵다는 것을 말해줍니다.</p><p>실제로 react-core team이 class component 와 functional component를 prototyping하여 컴파일러가 컴포넌트 성능을 개선시킬 수 있는지 테스트 해보았을 때, 클래스형 컴포넌트는 컴파일러가 최적화하는 것을 어렵게하는 일부 패턴들이 있었다고 합니다.</p><h1>reference</h1><ul><li><a href="https://youtu.be/dpw9EHDh2bM?t=287">https://youtu.be/dpw9EHDh2bM?t=287</a></li><li><a href="https://ko.reactjs.org/docs/hooks-intro.html#motivation">https://ko.reactjs.org/docs/hooks-intro.html#motivation</a></li></ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Data Fetching Library 어떻게 사용해야할까?]]></title>
        <id>Data Fetching Library 어떻게 사용해야할까?</id>
        <link href="https://kooku0.gihub.io/blog/data-fetching-library-어떻게-사용해야할까"/>
        <updated>2021-07-22T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Data fetching library가 탄생하게된 배경과 장점]]></summary>
        <content type="html"><![CDATA[<p>Data fetching library가 탄생하게된 배경과 장점</p><h2>기존 상태관리 라이브러리들의 문제점</h2><h3>1. 데이터 일관성 (Consistency)</h3><p>많은 Frontend Project들이 React, Vue 등을 이용해 SPA로 개발되고 있습니다. 이러한 SPA는 Application의 데이터가 Frontend와 Backend 두 곳에 있다는 것을 의미했습니다. Redux와 같은 상태관리 라이브러리를 사용할 때 Store를 Backend 상태에 대한 Data Cache로 사용하는 경우가 대부분이기 때문입니다. 데이터를 fetching 한 후 store에 저장하여 필요한 곳에서 사용하는 것이죠. 하지만 fetching 해온 데이터의 경우 시간이 지날수록 Backend 데이터와 일관성이 깨지기 때문에 데이터를 최신으로 유지하기 위해 주기적으로 호출함(refetching)으로써 Frontend, Backend 두 곳에 존재하는 데이터 상태를 동기화하여 데이터 일관성을 최대한 보장해주려고 노력합니다. 그리고 이는 추가적인 많은 코드작성이 필요하다는 것을 의미하기도 했습니다.</p><h3>2. 비동기 미들웨어 사용의 복잡함</h3><p>Redux에서 데이터를 비동기적으로 fetching 해오기 위해 redux-saga와 같은 미들웨어를 사용하는 경우가 많이 있습니다. 그리고 위에서 말한 문제점인 데이터 일관성의 문제를 해결하기 위해 데이터 패칭과 관련 상태와 액션들을 모두 정의하고 주기적인 refetching 로직이 추가됨에 따라 안그래도 거대한 Layer가 더욱 비대하고 복잡해졌습니다. Redux가 너무 많은 일들을 하게 된 것이죠.</p><h2>Data fetching library를 사용함으로써 얻을 수 있는 것들</h2><ul><li><strong>Server-state</strong> library (Redux, Mobx등은 <strong>client-state</strong> library로 비동기 데이터를 저장하는데 사용할 수 있지만 비효율적)</li><li>Server 와 Client간의 비동기 작업 관리</li></ul><h3>1. Data Synchronization</h3><p>Data fetching library를 사용하게 되면 데이터 일관성의 문제를 해결하는 역할이 개발자가 아닌 라이브러리로 바뀌게 됩니다. fetching 해온 데이터는 캐싱하여 관리하고 오래된 데이터는 background에서 자동으로 업데이트합니다.</p><h4>자동으로 background에서 refetching 하는 경우</h4><ul><li>query가 mount 되었을 때</li><li>window가 refocuse 되었을 때</li><li>network가 재연결 되었을 떄</li><li>query configure로 refetch interval를 설정했을 때</li></ul><h3>2. Simple</h3><p>일일히 정의해줘야할 data-fetching과 관련된 상태(status, data, isFetching, isSuccess, isError)를 한꺼번에 제어할 수 있으며 데이터 동기화 로직과 redux-saga에서 작업하는 비동기 로직을 완전히 걷어낼 수 있습니다.</p><h2>어떻게 사용해야할까?</h2><p>:::note
예시로 react-query를 이용하겠습니다.
:::</p><p>기본적으로 api call을 해와서 사용해야하는 모든 데이터들은 server-state-library를 사용해야합니다. api call을 해온 데이터는 서버에서 내려주는 데이터이기 때문에 client에서 서버의 데이터와 동기화를 하기 위해서 입니다. 그렇다면 컴포넌트에서 바로 사용하는 것일까요?</p><pre><code class="language-tsx" metastring="title=&quot;/src/components/TodoList.tsx&quot;" title="&quot;/src/components/TodoList.tsx&quot;">function TodoList() {
  // highlight-start
  const { status, data, error } = useQuery(&quot;todos&quot;, fetchTodoList, {
    suspense: true,
    staleTime: 5 * 60 * 1000,
  });
  // highlight-end

  if (status === &quot;loading&quot;) {
    return &lt;span&gt;Loading...&lt;/span&gt;;
  }

  if (status === &quot;error&quot;) {
    return &lt;span&gt;Error: {error.message}&lt;/span&gt;;
  }

  return (
    &lt;ul&gt;
      {data
        .filter((item) =&gt; item.enabled)
        .map((todo) =&gt; (
          &lt;li key={todo.id}&gt;{todo.title}&lt;/li&gt;
        ))}
    &lt;/ul&gt;
  );
}
</code></pre><p>보통 외부 라이브러리를 사용할 경우 바로 사용하는 것 보다 hooks로 감싸줘 컴포넌트와 인터페이스로 소통하면 좋습니다. 그래야 테스트코드도 짜기 쉽고 외부 라이브러리와의 의존성도 낮아지게 됩니다. 훅스를 사용해 각 api 마다 다르게 해줘야할 셋팅도 해줄 수 있죠. 예를 들면 몇 초마다 pulling 해올지, cache-key 등등...<br/>
<!-- -->이렇게 받은 데이터는 각 컴포넌트에서 바로 사용하지 않고 select를 이용해 가공한다던가 순수 함수를 이용해 각 컴포넌트에 맞게 가공해서 사용하면 됩니다.</p><pre><code class="language-tsx" metastring="title=&quot;/src/hooks/useTodos&quot;" title="&quot;/src/hooks/useTodos&quot;">function useTodos() {
  return useQuery(&quot;todos&quot;, fetchTodoList, {
    select: (todos: Todo[]) =&gt; {
      todos.filter(item =&gt; item.enabled);
    }
    suspense: true,
    staleTime: 5 * 60 * 1000,
  });
}

export default useTodos
</code></pre><pre><code class="language-tsx" metastring="title=&quot;/src/components/TodoList.tsx&quot;" title="&quot;/src/components/TodoList.tsx&quot;">import useTodos from &quot;src/hooks/useTodos&quot;;

function TodoList() {
  // highlight-next-line
  const { status, data, error } = useTodos();

  if (status === &quot;loading&quot;) {
    return &lt;span&gt;Loading...&lt;/span&gt;;
  }

  if (status === &quot;error&quot;) {
    return &lt;span&gt;Error: {error.message}&lt;/span&gt;;
  }

  return (
    &lt;ul&gt;
      {data
        .filter((item) =&gt; item.enabled)
        .map((todo) =&gt; (
          &lt;li key={todo.id}&gt;{todo.title}&lt;/li&gt;
        ))}
    &lt;/ul&gt;
  );
}
</code></pre><h2>reference</h2><ul><li><a href="https://ridicorp.com/story/how-to-use-redux-in-ridi/">리덕스 잘 쓰고 계시나요?</a></li><li><a href="https://react-query.tanstack.com/guides/does-this-replace-client-state">Does React Query replace Redux, MobX or other global state managers?</a></li><li><a href="https://blog.bitsrc.io/how-to-start-using-react-query-4869e3d5680d">How and Why You Should Use React Query</a></li><li><a href="https://maxkim-j.github.io/posts/react-query-preview">React Query 살펴보기</a></li><li><a href="https://blog.rhostem.com/posts/2021-02-01T00:00:00.000Z">React Query로 서버 상태 관리하기</a></li><li><a href="https://dev.to/g_abud/why-i-quit-redux-1knl">Why I Stopped Using Redux</a></li><li><a href="https://ko.wikipedia.org/wiki/CAP_%EC%A0%95%EB%A6%AC">CAP 정리</a></li></ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[next/image 에 대해]]></title>
        <id>next/image 에 대해</id>
        <link href="https://kooku0.gihub.io/blog/next-image-에-대해"/>
        <updated>2021-05-23T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Brand site를 개발하며 SEO를 높히기 위해 기존 Vue.js로 되어있는 프로젝트를 next.js 로 프레임워크를 변경하는 작업을 진행한 경험이 있습니다. 이때 새로운 프레임워크로 Next.js를 선택한 배경으로는 새로운 v10이 나왔기도 했고, 가장 인기있는 프레임워크 중 하나이기 때문입니다.]]></summary>
        <content type="html"><![CDATA[<p>Brand site를 개발하며 SEO를 높히기 위해 기존 Vue.js로 되어있는 프로젝트를 next.js 로 프레임워크를 변경하는 작업을 진행한 경험이 있습니다. 이때 새로운 프레임워크로 Next.js를 선택한 배경으로는 새로운 v10이 나왔기도 했고, 가장 인기있는 프레임워크 중 하나이기 때문입니다.</p><p>Next.js가 이번 v10이 나오게 되면서 많은 기능들이 추가 되었는데, 그 중 가장 관심이 갔던게 <a href="https://nextjs.org/blog/next-10#built-in-image-component-and-automatic-image-optimization"><code>next/image</code></a> 입니다.</p><pre><code class="language-jsx">import Image from &quot;next/image&quot;;

function Home() {
  return (
    &lt;&gt;
      &lt;h1&gt;My Homepage&lt;/h1&gt;
      &lt;Image
        src=&quot;/me.png&quot;
        alt=&quot;Picture of the author&quot;
        width={500}
        height={500}
      /&gt;
      &lt;p&gt;Welcome to my homepage!&lt;/p&gt;
    &lt;/&gt;
  );
}

export default Home;
</code></pre><p><code>next/image</code>는 next.js에서 제공하는 이미지 최적화 컴포넌트입니다. <code>Static HTML Export</code>에서는 사용할 수 없는데, 그 이유는 Server에서 돌아가기 때문입니다.</p><h3><code>next/image</code>가 수행하는 기능은 다음과 같습니다.</h3><ul><li>webp 포멧으로 자동변환</li><li>automatic lazy-loading</li><li>correct sizing across devices</li></ul><p>자동 이미지 최적화 기능이 매우 흥미로운데, image request가 들어올 때마다 device 크기별로 이미지 크기(image quality)를 조절해서 보내줍니다.</p><p><img src="../images/next-image.png" alt="next-image-header"/></p><p><code>next/image</code> header를 살펴보겠습니다.
실제 이미지는 <code>image/bg-kasa.png</code> path에 있지만 <code>_next/image</code> 로 요청된 것을 알 수 있습니다. query를 살펴보면 q=75 로 되어있는데 이는 image-quality를 75%로 보내달라는 것 입니다. 즉, 현재 viewport width가 크지 않으니 100% quality로 보내면 network상 손해이기 때문에 75%로 보내는 것 입니다. 그리고 업로드한 이미지는 파일포멧이 png인데, response headers를 보게되면 <code>Content-Type: image/webp</code> 인 것을 확인할 수 있습니다.(webp로 파일포멧 변경)</p><p><code>next/image</code>를 사용하면 브라우저에서 지원하는 경우 WebP와 같은 최신 형식의 이미지로 변환하여 전송하고, 이미지 크기를 조정하고 최적화할 수 있습니다. 이렇게 하면 viewPort가 더 작은 장치로 큰 이미지가 전송되는 것을 막을 수 있습니다.</p><p>생성 가능한 총 이미지 수를 줄이기 위해 <code>deviceSizes</code> 및 <code>imageSizes</code>를 구성 할 수도 있습니다.</p><pre><code class="language-js">module.exports = {
  images: {
    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
  },
};
</code></pre><h2>memory leak</h2><p><code>next/image</code>에서 memory leak 문제가 지속적으로 제기 되었습니다.</p><ul><li><a href="https://github.com/vercel/next.js/issues/20915">https://github.com/vercel/next.js/issues/20915</a></li><li><a href="https://github.com/vercel/next.js/issues/23189">https://github.com/vercel/next.js/issues/23189</a></li></ul><p><code>next/image</code>에 의해 최적화된 이미지는 만료일에 도달할 때까지 <code>&lt;distDir&gt;/cache../images</code>에 캐싱을 하고, 만료가 되면 캐싱된 이미지를 삭제하고 다시 최적화 이미지를 생성한 후 캐싱을 하는 기능이 있는데 이때 캐싱된 이미지를 삭제하는 라이브러리가 제대로 삭제를 시켜주지 않는 문제였습니다.</p><p>next.js 레포에 v9에서 v10으로 변경한 후 memory 사용량이 비정상적으로 높아졌으며 이로 인해 <code>next/image</code>의 image component를 제거해야만 했다라는 이슈가 계속 올라왔습니다.</p><p><img src="https://camo.githubusercontent.com/d88fbdef185b40d56b3a42a699550a469dbaa28f0ca50e2e344644900b972691/68747470733a2f2f692e696d6775722e636f6d2f434b54457863722e706e67" alt="img"/>
<img src="https://user-images.githubusercontent.com/13972013/104264344-72379580-5459-11eb-8285-7bb2a50adfa5.png" alt="img"/>
<img src="https://user-images.githubusercontent.com/6556627/105622606-adc25000-5dc7-11eb-8d65-130845bbbbd8.jpeg" alt="img"/></p><p>이에 next.js에서는 캐싱하고 삭제하는 라이브러리와 로직을 계속 변경하고 테스트를 하는 중인 것 같습니다.(canary에서 memory-leak 관련 피쳐들이 계속 올라오고 있습니다.)</p><p>제가 이 문제를 알게된 이유도 현재 next 서버를 돌리고 있는 ecs(Amazon Elastic Container Services)의 cpu와 memory의 사용량이 비정상적인 경우가 존재하였고, image가 pending 상태로 제대로 받아지지 않고 ecs가 비정상적으로 종료되는 문제가 계속 발생했기 때문입니다.</p><p>다음은 제가 작업한 프로젝트에서 <code>next/image</code>를 사용했다가 제거한 후의 cpu, memory 사용량입니다. <strong>5/11 15:30</strong> 에 제거한 후 배포를 했는데 확연한 차이를 확인할 수 있습니다. (그래프가 요동치는 곳의 색깔이 화려한데 8개이상의 pod가 비정상적으로 종료되고 실행되었기 때문입니다.)</p><p><img src="../images/cpu.png" alt="cpu"/></p><p><img src="../images/memory.png" alt="memory"/></p><h2>마무리</h2><p>현재 next.js의 stable version은 v10.2.0 입니다. <code>next/image</code>는 분명히 좋은 기능이지만 위의 이슈가 해결되지 않는다면 production에서 사용하기에는 어려울 것 같습니다.</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Web Vitals]]></title>
        <id>Web Vitals</id>
        <link href="https://kooku0.gihub.io/blog/web-vitals"/>
        <updated>2021-05-18T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[CRA를 통해 프로젝트를 생성하면 Web-Vitals를 봤을 겁니다. 이 Web Vitals은 어떤 작업을 하고 어떻게 사용하는 것 일까요?]]></summary>
        <content type="html"><![CDATA[<p>CRA를 통해 프로젝트를 생성하면 Web-Vitals를 봤을 겁니다. 이 Web Vitals은 어떤 작업을 하고 어떻게 사용하는 것 일까요?</p><h2>Overview</h2><p>Web Vietals은 웹에서 좋은 사용자 경험을 제공하는데 필수적인 품질에 대해 구글이 제공하는 지표입니다.</p><p>Google은 web 성능을 측정할 수 있는 여러 tools들을 제공했지만 일부 개발자들만 유용하게 사용할 뿐 많은 개발자들이 무관심했습니다.
이러한 문제를 해결하기 위해 Web Vitals의 환경을 단순화하고 사이트 성능 지표에 가장 중요한 Core Web Vitals에 집중하도록 돕게 발전했습니다.</p><h2>Core Web Vitals</h2><p>Core Web Vitals는 Web Vitals 중 가장 중요하게 생각되는 부분집합으로 LCP(Largest Contents Pain), FID(First Input Delay), CLS(Cumulative Layout Shift)가 포함되어 있습니다.</p><ul><li><strong>Largest Contentful Paint (LCP)</strong>: 페이지가 처음 로드되기 시작한 시점을 기준으로 뷰포트 내에 표시되는 가장 큰 이미지 또는 텍스트 블록의 렌더링 시간을 측정합니다.</li><li><strong>First Input Delay (FID)</strong>: 사용자가 페이지와 처음 상호작용한 시간(ex: 링크나 버튼을 클릭하거나 JavaScript 기반 컨트롤을 사용할 때)부터 실제로 이벤트 핸들러 처리를 시작할 수 때까지의 시간을 측정합니다.</li><li><strong>Cumulative Layout Shift (CLS)</strong>: 예기치 않은 <em>layout sift</em> 에 대한 모든 개별 레이아웃 이동 점수들의 합계를 측정합니다. <em>layout sift</em>는 element가 렌더링 된 프레임에서 다음 프레임으로 위치가 변경될때 마다 발생합니다.</li></ul><h2>Core Web Vitals을 측정하고 레포팅할 수 있는 Tools</h2><p>Google은 Core Web Vitals가 모든 web 경험에서 매우 중요하다고 생각합니다. 결과적으로 인기있는 Web Vitals 측정 도구들은 Core Web Vitals을 측정할 있습니다.</p><table><thead><tr><th></th><th>LCP</th><th>FID</th><th>CLS</th></tr></thead><tbody><tr><td><a href="https://developers.google.com/web/tools/chrome-user-experience-report">Chrome User Experience Report</a></td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td><a href="https://developers.google.com/speed/pagespeed/insights/">PageSpeed Insights</a></td><td>✔</td><td>✔</td><td>✔</td></tr><tr><td><a href="https://support.google.com/webmasters/answer/9205520">Search Console (Core Web Vitals report)</a></td><td>✔</td><td>✔</td><td>✔</td></tr></tbody></table><h2>JavaScript로 Core Web Vitals 측정하기</h2><p>Core Web Vitals는 standard web API를 사용하여 JavaScript에서 측정할 수 있습니다.</p><p>가장 쉬운 방법은 <a href="https://github.com/GoogleChrome/web-vitals">web-vitals</a> JavaScript library를 사용하는 방법입니다. 크기가 작고, production에서 사용할 때도 문제가 없으며 위에 나열된 Google tools에서 측정하는 방식으로 동일하게 측정합니다.</p><pre><code class="language-js">import { getCLS, getFID, getLCP } from &quot;web-vitals&quot;;

function sendToAnalytics(metric) {
  const body = JSON.stringify(metric);
  // Use `navigator.sendBeacon()` if available, falling back to `fetch()`.
  (navigator.sendBeacon &amp;&amp; navigator.sendBeacon(&quot;/analytics&quot;, body)) ||
    fetch(&quot;/analytics&quot;, { body, method: &quot;POST&quot;, keepalive: true });
}

getCLS(sendToAnalytics);
getFID(sendToAnalytics);
getLCP(sendToAnalytics);
</code></pre><p>Web Vitals library를 사용하여 Core Web Vitals를 측정하고 analytics endpoints로 전송하도록 사이트를 구성한 후, data를 집계하고 레포팅하여 페이징 방문자들의 75%이상이 권장 thresholds를 충족하는지 확인해야합니다.</p><h2>Use Case</h2><p>저는 Next.js 프로젝트에 web-vitals를 적용해보았습니다.
<a href="https://nextjs.org/docs/advanced-features/measuring-performance">https://nextjs.org/docs/advanced-features/measuring-performance</a></p><pre><code class="language-jsx">export function reportWebVitals({ id, name, label, value }) {
  // Use `window.gtag` if you initialized Google Analytics as this example:
  // https://github.com/vercel/next.js/blob/canary/examples/with-google-analytics/pages/_document.js
  window.gtag(&quot;event&quot;, name, {
    event_category:
      label === &quot;web-vital&quot; ? &quot;Web Vitals&quot; : &quot;Next.js custom metric&quot;,
    value: Math.round(name === &quot;CLS&quot; ? value * 1000 : value), // values must be integers
    event_label: id, // id unique to current page load
    non_interaction: true, // avoids affecting bounce rate.
  });
}
</code></pre><p>다음과 같이 구글 analytics에서 이벤트가 로깅된 것을 확인할 수 있습니다.</p><p><img src="../images/web-vitals-event.png" alt="web-vitals-event"/></p><p>로깅된 결과를 그래프로 볼 수 있는, GoogleChromeLabs에서 만든 오픈소스가 존재하는데, 바로 <a href="https://github.com/GoogleChromeLabs/web-vitals-report">Web Vitals Report</a> 입니다. 참고로 <a href="https://web-vitals-report.web.app/">Web Service</a>도 제공하고 있습니다.</p><p>GA4는 아직 지원하지 않기에, GA4 이하에서만 확인할 수 있습니다.
제공하는 정보를 보면, 모바일 or 데스크탑으로 유입된 유저들에 대한 Core Web Vitals를 수집하고, 평균점수를 확인 할 수 있습니다. 페이지별 Web Vitals과 여러 유저환경에서의 점수를 측정할 수 있어, 잘 활용한다면 매우 유의미한 결과를 얻을 수 있을 것이라 생각됩니다.
<img src="https://user-images.githubusercontent.com/326742/101584324-3f9a0900-3992-11eb-8f2d-182f302fb67b.png"/></p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Height Performace Animations]]></title>
        <id>Height Performace Animations</id>
        <link href="https://kooku0.gihub.io/blog/height-performace-animations"/>
        <updated>2021-05-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[rendering-process]]></summary>
        <content type="html"><![CDATA[<p><img src="../images/rendering-process.jpeg" alt="rendering-process"/></p><blockquote><p>출처: <a href="https://developers.google.com/web/fundamentals/performance/rendering/?hl=ko">developers.google.com</a></p></blockquote><p>JS와 CSS를 이용하여 animation을 구현해야할 때 성능 상 가장 고려해야할 부분이 Reflow(Layout) 와 Repaint(Paint)를 최소화하는 것이다.</p><p><img src="../images/rendering-process-2.gif" alt="rendering-process-2"/></p><small>&amp;nbsp;DOM 트리 및 스타일, 레이아웃 트리, 페인트 트리의 순서로 생성된다</small><p>렌더링 파이프라인에서 파악해야 할 가장 중요한 점은 각 단계에서 이전 작업의 결과가 새 데이터를 만드는 데 사용된다는 것이다. 예를 들어 레이아웃 트리에서 변경이 생겨 문서의 일부가 영향을 받으면 페인팅 순서도 새로 생성해야 한다.</p><p>요소에 애니메이션을 적용하면 브라우저는 모든 프레임 사이에서 이러한 작업을 해야 한다. 대부분의 디스플레이 장치는 화면을 초당 60번 새로 고친다(60fps). 요소의 움직임이 모든 프레임에 반영되어야 사람이 볼 때 부드럽게 느껴진다. 애니메이션에서 프레임이 누락되면 웹 페이지가 &#x27;버벅대는(janky)&#x27; 것처럼 보인다.</p><p>화면 주사율에 맞추어 렌더링 작업이 이루어져도 이 작업은 메인 스레드에서 실행되기 때문에 애플리케이션이 JavaScript를 실행하는 동안 렌더링이 막힐 수 있다.
JavaScript 작업을 작은 덩어리로 나누고 <code>requestAnimationFrame()</code> 메서드를 사용해 프레임마다 실행하도록 스케줄을 관리할 수 있다.  하지만 이건 JavaScript의 실행을 끊김없이 하는데 도움을 줄 뿐 실제로 메인쓰레드가 수행하는 작업의 양은 줄어들지 않는다.
메인쓰레드가 수행하는 작업의 양을 줄이는 작업이 바로 Reflow와 Repaint를 최소화하는 것이다.</p><h2>Reflow(Layout)</h2><p>DOM Tree 와 CSSOM로 만든 Render Tree를 바탕으로 DOM을 Viewport 내에 놓일 정확한 위치와 크기를 계산하여 적용하는 단계이다.
이 단계에서는 해당 DOM의 크기와 위치를 계산할 시 주변 노드(부모, 자식)들에 영향을 받게 된다. 따라서 이미 계산된 Layout에서 한 노드만 다시 계산하여도 주변 모든 노드들도 다시 계산하게 된다.
css 에서 다음의 속성들을 건드리게 되면 Reflow단계를 수행하게 된다.</p><ul><li>padding</li><li>margin</li><li>display</li><li>border</li><li>position</li><li>float</li><li>overflow</li><li>font-family</li><li>vertical-align</li><li>clear</li><li>bottom</li><li>left</li><li>right</li><li>font-weight</li><li>white-space</li><li>etc..</li></ul><h2>Repaint(Paint)</h2><p>Layout에서 계산된 결과를 바탕으로 Viewport에서 픽셀을 채워넣는 단계이다.
밑의 속성들이 변경되면 Repaint 단계가 일어난다.</p><ul><li>Visibility</li><li>background</li><li>text-decoration</li><li>background-image</li><li>background-repeat</li><li>border0radius</li><li>box-shadow</li><li>background-size</li><li>etc...</li></ul><p>만약 기존 CSS에서 background-color만 바꾸게 된다면 Reflow단계를 건너뛰고 Repaint단계만 수행하게 된다.</p><h2>Composite</h2><p>opacity, transform등의 속성은 Reflow, Repaint 단계를 거치지 않는다.
Reflow, Repaint를 모두 건너 뛰게 되어 연산이 절대적으로 줄게 된다.
따라서 animation을 구현할 때 transform을 통해서 구현하는 것이 성능 상에 이점이 많다.</p><p>특히나 Composite의 이점은 메인 스레드와 별개로 작동이 된다. Compositor thread는 JavaScript 실행이나 스타일 계산을 기다리지 않아, Composite만 하는 animation이 성능상 가장 부드럽다고 보는 이유이다.
(Layout이나 Paint를 다시 계산해야할 경우에는 main thread가 관여하게 된다.)</p><h2>정리</h2><p>animation 성능을 향상(부드러운 animation)시키기 위해서는 Reflow와 Repaint를 최소화하는게 중요하다.
width, height, left, right등의 요소를 사용하기 보다는 다음의 네가지 요소를 이용해서 animation을 구현하자.</p><ul><li>opacity</li><li>translate</li><li>rotate</li><li>scale</li></ul><p>실제로 React나 Vue에서 Virtual Dom을 사용하는 이유가 Reflow, Repaint를 여러번 하지않고, 모아서 한꺼번에 처리해 성능을 높히기 위함이다.</p><p>경우에 따라서는 Reflow를 해야만 하는 경우가 있다. 이러한 경우에는 해당 node를 position: absolute or fixed로 변경하는게 좋다. 그 이유는 Reflow를 사용할 시 부모, 자식등 영향을 받는 모든 node들이 계산하게 되는데, absolute, fixed일 경우 부모에게 종속되지 않는 새로운 layer에 그려지게 된다.</p><p>따라서 만약 해당 node에 reflow가 발생하게 된다면 해당 layer만 새로 업데이트 된다.</p><h3>Reference</h3><ul><li><a href="https://csstriggers.com/">Reflow, Repaint, Composit에 영향을 미치는 속성들을 더 알고싶다면 여기를 참고하자</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/rendering/?hl=ko">Rendering process &amp; performance에 대한 내용</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=en">Render-tree Construction, Layout, and Paint</a></li><li><a href="https://www.html5rocks.com/en/tutorials/speed/high-performance-animations/">hight performance animation의 조금 더 깊은 내용</a></li><li><a href="https://d2.naver.com/helloworld/5237120">최신 브라우저의 내부 살펴보기</a></li></ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Execution Context]]></title>
        <id>Execution Context</id>
        <link href="https://kooku0.gihub.io/blog/execution-context"/>
        <updated>2021-05-03T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[실행 컨텍스트는 자바스크립트에서 가장 중요한 핵심 개념 중 하나로, 실행할 코드에 제공할 환경 정보들을 모아놓은 객체입니다.]]></summary>
        <content type="html"><![CDATA[<p>실행 컨텍스트는 자바스크립트에서 가장 중요한 핵심 개념 중 하나로, <strong>실행할 코드에 제공할 환경 정보들을 모아놓은 객체</strong>입니다.
동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성하고 이를 콜 스택에 쌓아올렸다가, 가장 위에 있는 컨텍스트를 실행하는 식으로 전체 코드의 환경과 순서를 보장합니다.
여기서 &#x27;동일한 환경&#x27;, 즉 하나의 실행 컨텍스트를 구성할 수 있는 방법으로 전역공간, eval() 함수, 함수 등이 있습니다. 자동으로 생성되는 전역공간과 악마로 취급받는 eval을 제외하면 우리가 흔히 실행 컨텍스트를 구성하는 방법은 <strong>함수를 실행</strong>하는 것 뿐입니다.</p><p>한 실행 컨텍스트가 콜 스택의 맨 위에 쌓이는 순간이 곧 현재 실행할 코드에 관여하게 되는 시점입니다. 자바스크립트 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는 데 필요한 환경 정보들을 수집해서 실행 컨텍스트 객체에 저장합니다. 이 객체는 자바스크립트 엔진이 활용할 목적으로 생성할 뿐 개발자가 코드를 통해 확인할 수는 없습니다. 여기에 담기는 정보들은 다음과 같습니다.</p><ul><li>VariableEnvironment: 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보, 선언 시점의 LexicalEnvironment의 스냅샷으로, 변경 사항은 반영되지 않음.</li><li>LexicalEnvironment: 처음에는 VariableEnvironment와 같지만 변경 사항이 실시간으로 반영됨.</li><li>ThisBinding: this 식별자가 바라봐야 할 대상 객체.</li></ul><table><thead><tr><th align="center"></th><th align="left"></th></tr></thead><tbody><tr><td align="center">VariableEnvironment</td><td align="left">- environmentRecord (snapshot)</td></tr><tr><td align="center"></td><td align="left">- outerEnvironmentReference (snapshot)</td></tr><tr><td align="center">LexicalEnvironment</td><td align="left">- environmentRecord</td></tr><tr><td align="center"></td><td align="left">- outerEnvironmentReference</td></tr><tr><td align="center">ThisBinding</td><td align="left"></td></tr></tbody></table><h2>Lexical Environment</h2><p>Lexical Environment는 자바스크립트 코드에서 변수나 함수 등의 식별자를 정의하는데 사용하는 객체로 생각하면 쉽습니다. Lexical Environment는 식별자와 참조 혹은 값을 기록하는 <code>environmentRecode</code>와 <code>outerEnvironmentReference</code>라는 또 다른 Lexical Environment를 참조하는 포인터로 구성됩니다.</p><h3>Environment Recode</h3><p><code>environmentRecode</code>는 현재 컨텍스트와 관련된 식별자 정보들이 저장됩니다. 컨텍스트를 구성하는 함수에 지정된 매개변수 식별자, 선언한 함수가 있을 경우 그 함수 자체, var로 선언된 변수의 식별자 등이 식별자에 해당합니다. 컨텍스트 내부 전체를 처음부터 끝까지 쭉 훑어나가며 순서대로 수집합니다. 변수 정보를 수집하는 과정을 모두 마쳤더라도 아직 실행 컨텍스트가 관여할 코드들은 실행도기 전의 상태입니다. 코드가 실행되기 전임에도 불구하고 자바스크립트 엔진은 이미 해당 환경에 속한 코드의 변수명들을 모두 알고 있게 되는 것이죠. 이러한 과정을 <strong>Hoisting</strong>이라고 합니다.</p><h3>Outer Environment Reference</h3><p><code>outerEnvironmentReference</code>는 외부 Lexical Environment를 참조하는 포인터로, 중첩된 자바스크립트 코드에서 스코프 탐색을 하기 위해 사용됩니다. (따라서 Global Execution Context의 <code>outerEnvironmentReference</code>는 null 입니다.)</p><h2>Variable Environment</h2><p>VariableEnvironment에 담기는 내용은 LexicalEnvironment와 같지만 최초 실행 시의 스냅샷을 유지한다는 점이 다릅니다. 실행 컨텍스트를 생성할 때 VariableEnvironment에 정보를 먼저 담은 다음, 이를 그대로 복사해서 LexicalEnvironment를 만들고, 이후에는 LexicalEnvironment를 주로 활용하게 됩니다.</p><pre><code class="language-js">executionContext.LexicalEnvironment = executionContext.VariableEnvironment;
</code></pre><h3>Variable Environment vs Lexical Environment</h3><p><code>Variable Environment</code>와 <code>Lexical Environment</code>를 조금 더 알아보겠습니다.</p><pre><code class="language-js">var apple = &quot;apple&quot;;
let banana = &quot;banana&quot;;

{
  let banana = &quot;banana2&quot;;
  var orange = &quot;orange&quot;;
  console.log(apple, orange, banana);
}
</code></pre><p>처음에 <code>var</code> 키워드를 가진 변수들이 <code>Variable Environment</code>의 <code>Environment Records</code>에 등록이 됩니다. 그리고 Global EC 이기에 <code>Outer Environment Reference</code>는 null이 되게 됩니다.</p><p>그리고 <code>let</code> 키워드를 가진 변수들이 <code>Lexical Environment</code>의 Environment Records<code>에 등록이 됩니다.</code>var<code>키워드는 undefined로 초기화가 되는 반면에 </code>let` 키워드는 초기화가 되지않아 할당전 호출하게 되면 Reference Error가 발생하게 됩니다.</p><p><img src="../images/ec2.png" alt="ec-2"/></p><p>코드가 실행이 됨에 따라 각 변수에 값이 할당되게 됩니다.</p><p><img src="../images/ec3.png" alt="ec-3"/></p><p>이후 block scope를 만나게 되면 <code>Lexical Environment</code>의 <code>Environment Records</code>의 새로운 area를 만들어 기존과 다른 area에 식별자를 등록하게 됩니다. 그리고 이러한 area는 stack으로 관리하여 변수가 충하지 않습니다.</p><p><img src="../images/ec4.png" alt="ec-4"/></p><p>block scope가 실행이 되고 상위 area의 banana에 값이 할당됩니다.</p><p><img src="../images/ec5.png" alt="ec-5"/></p><p>이후 block scope의 실행이 끝나면 <code>Environment Records</code> block scope가 제거됩니다.</p><p><img src="../images/ec6.png" alt="ec-6"/></p><h2>ThisBinding</h2><p>this에 대해서는 다른 포스트에서 다루도록 하겠습니다.</p><h2>Reference</h2><ul><li>코어 자바스크립트 (정재남 지음)</li><li><a href="https://cabulous.medium.com/javascript-execution-context-lexical-environment-and-block-scope-part-3-fc2551c92ce0">JavaScript execution context — lexical environment and block scope :: carson</a></li></ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Throttling & Debouncing]]></title>
        <id>Throttling &amp; Debouncing</id>
        <link href="https://kooku0.gihub.io/blog/throttling-debouncing"/>
        <updated>2021-05-03T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Throttle과 Debounce는 자주 사용되는 이벤트나 함수의 실행 빈도를 줄여 성능상에 이점을 가져오기 위해 사용되는 기법입니다.]]></summary>
        <content type="html"><![CDATA[<p>Throttle과 Debounce는 자주 사용되는 이벤트나 함수의 실행 빈도를 줄여 성능상에 이점을 가져오기 위해 사용되는 기법입니다.</p><h2>Throttling</h2><p>Throttle은 일정 주기에 여러번 발생하는 이벤트를 한 번만 실행시키는 기법입니다.</p><h2>Debouncing</h2><p>Debounce는 여러번 발생하는 이벤트에서 가장 마지막 이벤트만 실행시키는 기법입니다.</p><h2>Throttle 과 Debounce의 차이점</h2><p>Debounce는 입력이 끝날때까지 무한적으로 기다리지만 Throttle은 입력이 시작되면 일정 주기로 실행됩니다.</p><h2>구현</h2><p><strong>입력에 따른 자동완성 코드로 예시를 들어보겠습니다.</strong></p><h3>Sample Code</h3><p>만약 다음과 같은 코드에서 <code>안녕하세요</code> 라고 입력했을 때 api는 총 12번 호출되게 됩니다.</p><pre><code class="language-js">const handleKeyup = (e) =&gt; {
  const value = e.target.value;
  fetch(`https://api.com/search?value=${value}`)
    .then((res) =&gt; {
      return res.json();
    })
    .then((res) =&gt; console.log(res));
};

document.getElementById(&quot;input&quot;).addEventListener(&quot;keyup&quot;, handleKeyup);
</code></pre><h3>Throttle</h3><p>키가 입력되었을 때마다 api가 호출되는것이 아닌 0.5s 마다 api가 호출됩니다.</p><pre><code class="language-js">let throttle = null;

function getAutoComplete(value) {
  fetch(`https://api.com/search?value=${value}`)
    .then((res) =&gt; {
      return res.json();
    })
    .then((res) =&gt; console.log(res));
}

const handleKeyup = (e) =&gt; {
  const value = e.target.value;
  if (!throttle) {
    throttle = setTimeout(() =&gt; {
      throttle = null;
      getAutoComplete(value);
    }, 500);
  }
};

document.getElementById(&quot;input&quot;).addEventListener(&quot;keyup&quot;, handleKeyup);
</code></pre><h3>Debounce</h3><p>키가 입력되는 이벤트가 끝나고 0.2s 동안 이벤트가 발생하지 않다면 api가 호출됩니다.</p><pre><code class="language-js">let debounce = null;

function getAutoComplete(value) {
  fetch(`https://api.com/search?value=${value}`)
    .then((res) =&gt; {
      return res.json();
    })
    .then((res) =&gt; console.log(res));
}

const handleKeyup = (e) =&gt; {
  const value = e.target.value;
  if (debounce) {
    clearTimeout(debounce);
  }

  debounce = setTimeout(() =&gt; {
    getAutoComplete(value);
  }, 200);
};

document.getElementById(&quot;input&quot;).addEventListener(&quot;keyup&quot;, handleKeyup);
</code></pre><h2>마무리</h2><p>Throttling 과 Debouncing 은 성능을 높힐 수 있는 정말 유용한 기법입니다. 예제에서는 autocomplete를 예시로 들었지만 지도 api등에서 사용할 때 매우 높은 성능 향상을 경험할 수 있을 것이라 생각됩니다.
underscore <code>_.debounce</code> 와 <code>_.throttle</code> 을 사용하면 쉽게 사용할 수도 있지만 직접 구현해보면서 어떻게 동작하는지 확인해볼 수 있었습니다.</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Use WebP images]]></title>
        <id>Use WebP images</id>
        <link href="https://kooku0.gihub.io/blog/use-webp-images"/>
        <updated>2021-05-03T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[구글이 Webp를 만들어서 무료로 뿌리는 이유는 돈 때문이다. 구글 혼자서 엄청난 인터넷 트래픽을 사용하고 있는데, 이미지 포맷만 최적화해도 서버 트래픽이 크게 줄어 서버비를 아낄 수 있다. 게다가 인터넷 속도가 빨라질수록 광고 매출도 늘어나기 때문에 구글은 항상 인터넷 속도를 올리려고 노력한다.]]></summary>
        <content type="html"><![CDATA[<blockquote><p>구글이 Webp를 만들어서 무료로 뿌리는 이유는 돈 때문이다. 구글 혼자서 엄청난 인터넷 트래픽을 사용하고 있는데, 이미지 포맷만 최적화해도 서버 트래픽이 크게 줄어 서버비를 아낄 수 있다. 게다가 인터넷 속도가 빨라질수록 광고 매출도 늘어나기 때문에 구글은 항상 인터넷 속도를 올리려고 노력한다.</p><p><a href="https://namu.wiki/w/WebP">WebP 제작 배경 :: 나무위키</a></p></blockquote><p>webp 포멧의 이미지는 JPEG 및 PNG 이미지보다 작으며 일반적으로 파일크기가 25~35% 작습니다. 이로인해 First load times를 줄일 수 있습니다</p><ul><li>YouTube는 Thumbnail 이미지를 WebP로 전환한 결과 페이지로드 속도가 10% 빨라졌습니다.</li><li>Facebook은 WebP를 사용하도록 전환했을 때 JPEG와 비교했을 경우 25 ~ 35%, PNG와 비교했을 경우 80%의 파일크기 절감을 경험했습니다.</li></ul><p>WebP는 JPEG, PNG 및 GIF 이미지를 완전히 대체할 수 있으며, lossless and lossy compression 을 모두 지원합니다. <code>lossless compression</code> 은 데이터의 손실이 발생하지않고 <code>lossy compression</code>는 파일크기가 줄어들고 이미지 화질을 떨어지게 하는 압축입니다.</p><h2>Convert images to WebP</h2><p>이미지를 WebP로 변환할 때 보통 <a href="https://developers.google.com/speed/webp/docs/using">cwebp command-line tool</a> 와 <a href="https://github.com/imagemin/imagemin-webp">Imagemin WebP plugin</a>을 사용합니다. Imagemin WebP plugin은 Webpack이나 Gulp와 같은 build tools를 사용하는 프로젝트에 최고의 선택이고 CLI는 image를 한 번만 변환시킬 때 사용하기 좋습니다.</p><p>이미지를 WebP로 변환할 때 다양한 압축 설정을 지정할 수 있지만 가장 중요하게 봐야할 것이 품질수준입니다. 0(최약)에서 100(최상)까지 품질 수준을 지정할 수 있기에 필요에 맞는 이미지 품질과 파일크기를 고려하여 선택하면 됩니다.</p><h3>Use cwebp</h3><p>간단히 하나의 파일을 변경할 때는 cwebp를 사용하면 됩니다.</p><p>default:</p><pre><code class="language-bash">cwebp images/flower.jpg -o images/flower.webp
</code></pre><p>using a query level of <code>50</code>:</p><pre><code class="language-bash">cwebp -q 50 images/flower.jpg -o images/flower.webp
</code></pre><p>Convert all files in a directory:</p><pre><code class="language-bash">for file in images/*; do cwebp &quot;$file&quot; -o &quot;${file%.*}.webp&quot;; done
</code></pre><h3>Use Imagemin</h3><p>Imagemin은 Webpack과 같은 build tools를 사용하는 프로젝트에서 사용하기 좋습니다.</p><p>간단히 <a href="https://www.npmjs.com/package/imagemin-webp-webpack-plugin">imagemin-webp-webpack-plugin</a>을 사용하면 될 것 같습니다.</p><pre><code class="language-js">const ImageminWebpWebpackPlugin = require(&quot;imagemin-webp-webpack-plugin&quot;);

module.exports = {
  plugins: [new ImageminWebpWebpackPlugin()],
};
</code></pre><h2>Serve WebP images</h2><p>만약 WebP를 제공하지 않는 <a href="https://caniuse.com/?search=webp">브라우저</a>라면 fallback을 설정할 수도 있습니다.</p><h4>Before:</h4><pre><code class="language-html">&lt;img src=&quot;flower.jpg&quot; alt=&quot;&quot; /&gt;
</code></pre><h4>After:</h4><pre><code class="language-html">&lt;picture&gt;
  &lt;source type=&quot;image/webp&quot; srcset=&quot;flower.webp&quot; /&gt;
  &lt;source type=&quot;image/jpeg&quot; srcset=&quot;flower.jpg&quot; /&gt;
  &lt;img src=&quot;flower.jpg&quot; alt=&quot;&quot; /&gt;
&lt;/picture&gt;
</code></pre><p><code>&lt;picture&gt;</code>안의 <code>&lt;source&gt;</code> 및 <code>&lt;img&gt;</code> 태그는 상위에 대한 fallback입니다.</p><h3>picture</h3><p><code>&lt;picture&gt;</code>는 0개 이상의 <code>&lt;source&gt;</code>와 하나의 <code>&lt;img&gt;</code> 태그의 wrapper입니다.</p><h3>source</h3><p><code>&lt;source&gt;</code> 태그는 미디어 리소스를 지정합니다.</p><p>브라우저에 지원되는 형식을 순서대로 따라가며, 만약 지원하지 않는 경우 <code>&lt;img&gt;</code> 태그에 지정된 이미지로 대체됩니다.</p><h3>image</h3><p><code>&lt;img&gt;</code>의 경우 <code>&lt;picture&gt;</code> 태그를 지원하지 않는 경우 <code>&lt;img&gt;</code> 태그의 image를 로드하게 됩니다.</p><h2>Verify WebP usage</h2><p>Lighthouse는 사이트의 모든 이미지가 WebP를 사용하지는 체크하고, 사용하지 않는 이미지를 나열합니다.</p><h2>Reference</h2><ul><li><a href="https://web.dev/serve-images-webp/">Use WebP images :: WebDev</a></li></ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React v17]]></title>
        <id>React v17</id>
        <link href="https://kooku0.gihub.io/blog/react-v17"/>
        <updated>2021-04-20T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[2020년 10월 20일 React v17이 릴리즈 되었다.]]></summary>
        <content type="html"><![CDATA[<p>2020년 10월 20일 React v17이 릴리즈 되었다.
리엑트 이전 주요 릴리즈 이후 2년 반만에 릴리즈되는 것으로 많은 관심들이 있었는데 과연 어떤 내용들이 추가되었는지 살펴보자.</p><h2>No New Features</h2><p>처음에 밝히듯히 새롭게 추가되는 기능들은 없다.
이번 릴리즈는 <strong>리엑트를 더 쉽게 upgrade</strong> 가능하도록 하는데 초점이 맞춰졌다.</p><h2>Gradual Upgrades</h2><p>15, 16 버전의 React를 사용하고 있을 때 17 버전으로 업그레이드를 위해서는 전체 app을 업그레이드 했어야했다.
만약 예전에 작성되었고, 유지보수가 제대로 이루어지지 않은 코드일 경우 이러한 업그레이드는 힘들어질 수 있으며 이럴때 두가지 버전의 React를 사용할 수 있지만 Event 문제가 발생했다.
React 17에서 이러한 문제점들을 수정하였으며 React 18과 같은 다음 버전이 나왔을 때 업그레이드 시 더 많은 옵션을 사용할 수 있게 되었다.</p><p>이전처럼 전부 한꺼번에 업그레이드를 하거나, 하위 라우터 몇 개는 이전 버전을 사용하게 둘 수도 있게 되었다. 이를 Gradual Upgrades라고 부른다.
하지만 Gradual Upgrades는 추천되지않으며 앞에 설명한 앱 전부를 업그레이드하는 것을 추천한다.</p><h2>Changes to Event Delegation</h2><p>앞의 Gradual Upgrades를 설명하면서 두가지 버전의 React를 사용할 때 Event 문제가 발생할 수도 있다고 하였다.
React 17에서는 이를 해결하기 위해서(두가지 React버전을 사용할 수 있게 하기위해) React event system의 변경이 필요하였다.</p><p>React 17에서는 event handler를 <code>docuemnt</code>에 달지않고 React tree가 랜더되는 root DOM container에 달았다.</p><pre><code class="language-jsx">const rootNode = document.getElementById(&quot;root&quot;);
ReactDOM.render(&lt;App /&gt;, rootNode);
</code></pre><p>이전 버전들에서는 <code>document.addEventListener()</code>를 사용했다면 React 17부터는 <code>rootNode.addEventListener()</code>를 사용하게 된다.</p><h2>Other Breaking Changes</h2><p>이외에 여러 자잘자잘한 버그들이 수정되었는데
한 가지 눈에 띄는 것이 있어 소개하려고한다. (실제 프로젝트를 진행하다 발견한 문제인데 이번 v17에 추가되어 기뻤다.)</p><ul><li>Add the <code>disableRemotePlayback</code> property for <code>video</code> elements. (@tombrowndev in <a href="https://github.com/facebook/react/pull/18619">#18619</a>)</li></ul><p><code>video</code> Tag에 <code>disableRemotePlayback</code> 속성이 추가된 것인데 <a href="(https://github.com/facebook/react/issues/18618)">Issue</a>를 살펴보면 자세히 알 수 있다.</p><p>웹페이지에 <code>video</code> Tag를 이용해 동영상을 넣고 안드로이드 휴대폰으로 접속하면 동영상 위에 <code>chromecast</code> icon이 보여지게 된다. <a href="https://stackoverflow.com/questions/28153166/android-chrome-chromecast-icon-over-html5-video-position">android-chrome-chromecast-icon-over-html5-video-position::stackoverflow</a></p><p>이것은 <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/disableRemotePlayback">MDN Web Docs</a>에 나오듯 <code>disableRemotePlayback</code>을 true로 두면 없앨 수 있는데 React에서 지원하지 않았다가 이번 v17에서 사용할 수 있게 된 것이다.</p><h2>Reference</h2><ul><li><a href="https://reactjs.org/blog/2020/10/20/react-v17.html">React v17.0</a></li></ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DOMContentLoaded vs onLoad]]></title>
        <id>DOMContentLoaded vs onLoad</id>
        <link href="https://kooku0.gihub.io/blog/domcontentloaded-vs-onload"/>
        <updated>2021-04-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Overview]]></summary>
        <content type="html"><![CDATA[<h2>Overview</h2><p>script 태그의 <code>async</code> 와 <code>defer</code>에 대해서 공부하던 중 <code>DOMContentLoaded</code>와 <code>load</code> 이벤트에 대해서 알게되었고 두 이벤트에 대해 정리하였습니다.</p><h2>Docs</h2><p>공식문서에는 다음과 같이 말하고 있습니다.</p><blockquote><p><code>DOMContentLoaded</code> 이벤트는 초기 HTML 문서를 완전히 불러오고 분석했을 때 발생합니다. 스타일 시트, 이미지, 하위 프레임의 로딩은 기다리지 않습니다.</p><p><a href="https://developer.mozilla.org/ko/docs/Web/API/Window/DOMContentLoaded_event">DOMContentLoaded :: MOZ</a></p><p><code>load</code> 이벤트는 리소스와 그것에 의존하는 리소스들의 로딩이 완료되면 실행됩니다.</p><p><a href="https://developer.mozilla.org/ko/docs/Web/API/Window/load_event">load :: MOZ</a></p></blockquote><p>Chrome dev tool에서 측정해보면 <!-- -->`<!-- -->DOMContentLoaded<!-- -->`<!-- -->가 stylesheet와 img등의 리소스와는 상관없다는 것을 확인할 수 있습니다.</p><p><img src="../images/domcontentload.png"/></p><h2>async &amp; defer</h2><p>script 태그 <code>async</code> 와 <code>defer</code> 는 언제 script가 언제 실행되는지에 따라서 구분이 됩니다. <code>async</code>의 경우 script가 로드되면 바로 수행이 되는 반면(dom parsing을 block할 수 있다.) <code>defer</code>는 script가 로드 되고, dom parsing이 끝난 후에 실행이 되는 차이점이 있습니다. <br/>
이 차이점말고도 다른 차이점이 있는데, <code>async</code>의 경우 <code>window.load</code> 이벤트가 실행되기 전에 script의 실행을 보장하고, <code>defer</code>의 경우에는 <code>domContentLoaded</code> 이벤트가 발생하기 전에 script를 실행하는 것을 보장합니다.</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;ko&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;

    &lt;script defer src=&quot;./defer.js&quot;&gt;&lt;/script&gt;
    &lt;script async src=&quot;./async.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;./sample.js&quot;&gt;&lt;/script&gt;
    &lt;link
      rel=&quot;stylesheet&quot;
      href=&quot;https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.0.0-alpha/css/bootstrap.min.css&quot;
    /&gt;
    &lt;script&gt;
      console.log(&quot;in head&quot;);
      window.addEventListener(&quot;DOMContentLoaded&quot;, function () {
        console.log(&quot;DOMContentLoaded is loaded&quot;);
      });

      window.onload = function () {
        console.log(&quot;window is loaded&quot;);
      };
    &lt;/script&gt;
    &lt;title&gt;React App&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;
    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
    &lt;script&gt;
      console.log(&quot;end of body&quot;);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>다음과 같은 결과가 콘솔에 찍혔습니다.</p><pre><code class="language-shell">async
in sample
in head
end of body
defer
DOMContentLoaded is loaded
window is loaded
</code></pre><h2>마무리</h2><p>전통적인 성능 측정 방식은 브라우저에서 발생하는 이벤트를 사용하는 것이었습니다. 웹 페이지가 로딩될 때 DOMContentLoaded, load 이벤트가 발생하며, 각 이벤트가 발생하는 시점으로 성능을 측정하게 되는데, DOMContentlLoaded 이벤트, load 이벤트 발생 시점이 빠를수록, 그리고 두 이벤트 발생 구간의 폭이 좁을수록 성능이 좋다고 말합니다.</p><p>하지만 현재는 DOMContentLoaded or load 가 user가 screen에서 실제로 보는 것과 차이가 있기에 FCP(First Contentful Paint)로 성능을 측정합니다. FCP는 이지가 처음 로드되기 시작한 시점을 기준으로 뷰포트 내에 가장 큰 이미지 또는 텍스트 블록의 렌더링 시간을 측정합니다.</p><h2>Reference</h2><ul><li><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/analyzing-crp">주요 렌더링 경로 성능 분석 :: developers.google.com</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/DOMContentLoaded_event">DOMContentLoaded :: MOZ</a></li><li><a href="https://ui.toast.com/fe-guide/ko_PERFORMANCE">성능 최적화 :: TOAST UI</a></li></ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Render-Blocking CSS]]></title>
        <id>Render-Blocking CSS</id>
        <link href="https://kooku0.gihub.io/blog/render-blodking-css"/>
        <updated>2021-04-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[기본적으로 CSS는 rendering-blocking resource입니다. 브라우저가 렌더링을 하기 위한 render tree를 생성하기 위해서는 DOM tree 와 CSSOM이 모두 필요합니다. CSSOM이 만들어지지 않았다면 render tree도 만들수가 없는거죠.]]></summary>
        <content type="html"><![CDATA[<p>기본적으로 CSS는 rendering-blocking resource입니다. 브라우저가 렌더링을 하기 위한 render tree를 생성하기 위해서는 DOM tree 와 CSSOM이 모두 필요합니다. CSSOM이 만들어지지 않았다면 render tree도 만들수가 없는거죠. <br/>
CSS가 사용 가능해질 때까지(CSSOM이 만들어질 때까지)렌더링이 차단되기에 <strong>media type</strong>과 <strong>media query</strong>를 사용하여 문제를 해결할 수 있습니다.</p><pre><code class="language-html">&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; /&gt;
&lt;link href=&quot;print.css&quot; rel=&quot;stylesheet&quot; media=&quot;print&quot; /&gt;
&lt;link href=&quot;other.css&quot; rel=&quot;stylesheet&quot; media=&quot;(min-width: 40em)&quot; /&gt;
</code></pre><p>첫 번째 줄은 항상 렌더링을 차단합니다. 반면에 두 번째 stylesheet 는 콘텐츠가 인쇄될 때만 렌더링을 차단합니다. 마지막 stylesheet는 브라우저가 실행하는 <strong>media query</strong>와 일치할 때 브라우저가 렌더링을 차단합니다.</p><h3>media=&quot;all&quot;</h3><p><img src="../images/media-all.png"/></p><h3>media=&quot;print&quot;</h3><p><img src="../images/media-print.png"/></p><h2>마무리</h2><p>styleseet 설정으로 성능을 높힐 수 있는 방법을 살펴보았습니다. 렌더링을 빠르게 하기 위한 한 가지 팁으로만 생각하면 될 것 같습니다.</p><h2>Reference</h2><ul><li><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css">Render-Blocking CSS :: developer.google.com</a></li></ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Resource Priority]]></title>
        <id>Resource Priority</id>
        <link href="https://kooku0.gihub.io/blog/resource-priority"/>
        <updated>2021-04-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[css파일과 같은 리소스를 로드해올 때 다음과 같이 많이 사용하는데,]]></summary>
        <content type="html"><![CDATA[<p>css파일과 같은 리소스를 로드해올 때 다음과 같이 많이 사용하는데,</p><pre><code class="language-html">&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;
</code></pre><p>좀 더 나아가서 이러한 리소스의 우선순위를 지정할 수 있는 <code>link</code> 태그의 <code>preload</code>, <code>preconnect</code>, <code>prefetch</code>, <code>dns-prefetch</code>에 대해서 알아보겠습니다.</p><h2>preload</h2><p>현재 페이지에서 사용될 것이 확실한 리소스들을 최우선 순위로 가지고 와야할 때 <code>preload</code>를 사용해야합니다.</p><pre><code class="language-html">&lt;link rel=&quot;preload&quot; as=&quot;script&quot; href=&quot;super-important.js&quot; /&gt;
&lt;link rel=&quot;preload&quot; as=&quot;style&quot; href=&quot;critical.css&quot; /&gt;
</code></pre><p><code>preload</code>는 위의 코드와 같이 <code>&lt;link rel=&quot;preload&quot; as=&quot;...&quot;&gt;</code>와 같이 사용합니다.</p><h3>주의사항</h3><h4><code>as</code> 속성 사용</h4><p><code>as</code> 속성을 사용하여 리소스의 유형을 브라우저에게 알려줘야합니다. 올바른 유형이 설정되어 있지 않다면 브라우저는 해당 리소스를 요청하지 않습니다.</p><h4>중복 리소스 참조</h4><p><code>preload</code>는 브라우저가 반드시 리소스를 가져오게 만듭니다. 리소스를 중복 참조하면 중복된 개수만큼 리소스를 가져오기 때문에 리소스를 중복해서 참조하지 않도록 해야 합니다.</p><h4>반드시 사용되는 리소스에만 사용</h4><p><code>preload</code>는 현재 페이지에서 반드시 사용되는 리소스에만 사용되어야 합니다.</p><p><img src="../images/preload-warning.png"/></p><p><code>preload</code>를 사용했지만 현재 페이지에서 3초 내로 사용되지 않다면 위와 같은 warning이 출력되게 됩니다.</p><h3>사용 사례</h3><p>이번에는 <code>preload</code>를 사용하기 좋은 리소스를 살펴보도록 하겠습니다.</p><h4>폰트</h4><p>사용자가 사이트의 폰트를 기다리는 시간을 감소시키고, 시스템 폰트와 선언된 폰트의 충돌을 해결할 수 있습니다.</p><pre><code class="language-html">&lt;link rel=&quot;preload&quot; as &quot;font&quot; crossorigin=&quot;crossorigin&quot; type=&quot;font/woff2&quot;
href=&quot;myfont.woff2&quot;&gt;
</code></pre><h4>Critical Rendering Path의 CSS와 JavaScript</h4><p>페이지 초기 렌더링 시 반드시 로드되어야할 리소스들을 <code>preload</code>로 우선적으로 로드해야합니다.</p><h3>Chrome DevTools</h3><p>Chrome DevTools의 network panel에서 priority가 Highest로 찍힌걸 확인할 수 있습니다.</p><p><img src="../images/preload-highest.png"/></p><h2>preconnect &amp; dns-prefetch</h2><h3>preconnect</h3><p>browser가 server로 부터 resource를 요청하기 전에 connection이 필요합니다. 이 connection을 하기 위해서는 다음의 3 step이 있습니다.</p><ul><li>Look up the domain name and resolve it to an IP address (dns-lookup)</li><li>Set up a connection to the server</li><li>Encrypt the connection for security</li></ul><p>각 step에서 브라우저는 data 조각을 서버로 보내고 응답을 받습니다. 이러한 origin으로 부터 server로 갔다가 되돌아 오는 것을 round-trip 이라고 부릅니다.</p><p>network 상황에 따라서 한 번의 round-trip이 상당한 시간이 소요될 수 있고, 세번의 round-trip을 포함한 connection setup 과정이 네트워크 환경이 최적화 되지 않은 경우에 세번 이상이이 될 수도 있습니다. 이러한 과정을 리소스가 필요한 시점에 하는것이 아니라 미리 해놓는다면, 리소스가 필요한 시점에 더 빨리 로드할 수 있는데, <code>&lt;link rel=preconnect&gt;</code> 와 <code>&lt;link rel=dns-prefetch&gt;</code>를 통해서 할 수 있습니다.</p><p><code>preconnect</code>와 <code>dns-prefetch</code>는 실제로 리소스를 다운하는게 아니라 리소스 다운을 위한 network connection을 미리 해두는 것 입니다.</p><p><img src="../images/preconnect.png"/></p><p>이러한 방법으로 connection setup을 하는 100ms~500ms정도의 시간을 단축할 수 있습니다.</p><h3>dns-prefetch</h3><p><code>preconnect</code>를 사용하여 미리 connection setup을 하는 과정은 critical connections들에 사용을 하고 대부분의 경우에는 <code>&lt;link rel=dns-prefetch&gt;</code>를 사용하는 것이 좋습니다. <code>dns-prefetch</code>를 통하여 첫 번째 단계인 DNS-loopup만 수행해 20~120ms 정도의 시간을 줄일 수 있습니다.
또한 <code>preconnect</code>를 지원하지 않는 브라우저가 많기에 이에 대한 fallback으로 <code>dns-prefetch</code>를 사용할 수도 있습니다.</p><pre><code class="language-html">&lt;link rel=&quot;preconnect&quot; href=&quot;http://example.com&quot; /&gt;
&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://example.com&quot; /&gt;
</code></pre><h3>주의사항</h3><p>preconnect는 외부 도메인과 연결을 구축하기 때문에 많은 CPU 시간을 차지할 수 있습니다. 보안 연결의 경우 더 많은 시간을 차지할 수 있습니다. 10초 이내로 브라우저가 닫힌다면, 이전의 모든 연결 작업은 낭비되는 것이기 때문에 브라우저가 빨리 닫힐 수 있는 페이지에서는 preconnect를 사용하지 않는 것이 좋습니다.</p><h5>crossorigin</h5><pre><code class="language-html">&lt;link rel=&quot;preconnect&quot; href=&quot;https://example.com/ComicSans&quot; crossorigin /&gt;
</code></pre><p>fonts와 같은 일부 리소스들의 경우 <code>preconnect</code>와 함께 <code>crossorigin</code> 속성을 추가해야합니다.
<code>crossorigin</code>속성을 가하지 않는다면 브라우저는 DNS-loopup만 수행하게 됩니다.</p><h3>사용 사례</h3><h4>정확한 경로를 알 수 없을 때</h4><p>주어진 CDN으로 부터 리소스를 가져와야 한다는 것은 알지만 정확한 경로를 모르는 상황이 발생할 수 있습니다. 예를 들면 브라우저 별로 가져와야 하는 JQuery 등의 리소스 버전이 다를 때 가져와야 할 CDN 주소는 알지만 정확한 경로는 알지 못하는 상황을 이야기할 수 있습니다.</p><p>이러한 경우 브라우저는 리소스를 가져오지는 않지만 서버에 미리 연결하여 연결에 필요한 시간을 절약할 수 있습니다. 브라우저는 파일이 필요하기 전에는 리소스를 가져오지 않지만 적어도 연결은 먼저 처리해서 리소스를 요청하고 가져오는 여러 번의 왕복을 기다리지 않아도 됩니다.</p><h4>미디어 스트리밍</h4><p>스크립트가 로드되고 스트리밍 데이터를 처리할 준비가 될 때까지 스트리밍을 기다리고 싶을 수 있습니다. preconnect는 미리 연결을 하기 때문에 리소스를 가져올 준비가 되면 연결을 설정하는 것이 아니라 미리 연결된 설정에 따라 리소스를 가져와 연결을 설정하는 대기 시간을 줄 일 수 있습니다.</p><h3>Chrome DevTools</h3><p>다음과 같이 실제로 리소스를 다운받지는 않는 걸 알 수 있다.</p><pre><code class="language-html">&lt;link rel=&quot;preconnect&quot; as=&quot;style&quot; href=&quot;./style.css&quot; /&gt;
</code></pre><p><img src="../images/preconnect-network.png"/></p><h2>prefetch</h2><p>미래에 사용될 것이라고 예상되는 리소스들을 <code>prefetch</code>합니다. 브라우저는 미래에 사용될 리소스들을 가져와 캐시에 저장합니다.
<code>prefetch</code>는 사용자가 다음에 할 행동을 미리 준비하는데 적합한 기능입니다. 예를 들어, 결과 목록에서 첫 번째 상세 페이지를 가져오거나 다음 페이지를 가져오는 것을 이야기할 수 있습니다.</p><pre><code class="language-html">&lt;link rel=&quot;prefetch&quot; href=&quot;page-2.html&quot; /&gt;
</code></pre><h3>주의사항</h3><h4>재귀적으로 동작하지 않는다.</h4><pre><code class="language-html">&lt;link rel=&quot;prefetch&quot; href=&quot;page-2.html&quot; /&gt;
</code></pre><p>위의 코드와 같이 <code>prefetch</code>를 사용한다면, <code>page-2.html</code>이라는 HTML 리소스를 가져올 수 있지만 <code>page-2.html</code>에서 사용되는 CSS등의 리소스들은 가져오지 않습니다.</p><h3>Chrome DevTools</h3><p>다음과 같이 priority가 Lowest인 것을 확인할 수 있습니다.</p><p><img src="../images/prefetch-network.png"/></p><h2>요약</h2><p>현재 페이지에서 반드시 필요한 리소스(Render-block resource or fonts)는 <code>preload</code> 합니다.
<code>preconnect</code>와 <code>dns-prefetch</code>는 다른 도메인에서 리소스를 다운로드할 예정이지만 리소스의 정확한 URL을 모르는 경우 페이지 속도를 개선하는데 유용합니다. 예로 JavaScript 라이브러리, 이미지 또는 글꼴을 포하는 CDN이 있습니다. 그리고 중요한 리소스에 대해서만 <code>preconnect</code>를 이용하고 나머지는 <code>dns-prefetch</code>를 사용하는 것이 좋습니다.
현재 사용하지 않지만 미래에 사용되는 리소스는 <code>prefetch</code>를 하는게 좋습니다.</p><h2>Reference</h2><ul><li><a href="https://beomy.github.io/tech/browser/preload-preconnect-prefetch/">리소스 우선순위::Beomy</a></li><li><a href="https://web.dev/preconnect-and-dns-prefetch/">preconnect-and-dns-prefetch::web.dev</a></li><li><a href="https://web.dev/uses-rel-preconnect/">uses-rel-preconnect::web.dev</a></li></ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[React fiber & reconciliation]]></title>
        <id>react-fiber</id>
        <link href="https://kooku0.gihub.io/blog/react-fiber"/>
        <updated>2021-04-04T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Reconciliation은 React의 "비교(diffing)" 알고리즘입니다. 이 비교 알고리즘 덕분에 컴포넌트의 갱신이 예측 가능해지면서도 고성능 앱이라고 불러도 손색없을 만큼 충분히 빠른 앱을 만들 수 있습니다]]></summary>
        <content type="html"><![CDATA[<p>Reconciliation은 React의 &quot;비교(diffing)&quot; 알고리즘입니다. 이 비교 알고리즘 덕분에 컴포넌트의 갱신이 예측 가능해지면서도 고성능 앱이라고 불러도 손색없을 만큼 충분히 빠른 앱을 만들 수 있습니다</p><h3><a href="https://github.com/kooku0/kooku-s-log/blob/main/content/blog/react/react-reconciliation-%26-fiber.md#react-rendering-logic"></a>React rendering logic</h3><p>리액트 컴포넌트가 화면에 렌더링 되는 과정은 다음과 같습니다.</p><ol><li>리액트의 JSX가 <code>React.createElement</code>로 바벨에 의해 트랜스파일링됨</li><li><code>React.createElement</code>함수 호출에 의해 리액트 엘리먼트 트리가 반환됨</li><li>React의 <code>reconciliation</code> 알고리즘에 의해 리액트 엘리먼트 트리를 재귀적으로 순회하면서 이전 트리와 현재 트리의 변경사항을 비교한다음 변경된 부분만 실제 DOM에 반영함 (Virtual-DOM)</li></ol><h2><a href="https://github.com/kooku0/kooku-s-log/blob/main/content/blog/react/react-reconciliation-%26-fiber.md#overview"></a>Overview</h2><p>React를 사용하다 보면, &quot;<code>render()</code> 함수는 React 엘리먼트 트리를 만드는 것이다.&quot; 라고 생각이 드는 순간이 있습니다. state나 props가 갱신되면 <code>render()</code>함수는 새로운 React 엘리먼트 트리를 반환하기 때문입니다. 이때 React는 방금 반환된 트리에 맞게 가장 효과적으로 UI를 갱신하는 방법을 알아야할 필요가 있습니다.</p><p>하나의 트리를 가지고 다른 트리로 변환하기 위한 최소한의 연산 수를 구하는 알고리즘 문제를 풀기 위한 일반적인 해결책들은 n개의 엘리먼트가 있는 트리에 대해 O(n^3)의 복잡도를 가집니다.</p><p>React에 이 알고리즘을 적용한다면, 1000개의 엘리먼트를 그리기 위해 10억 번의 비교 연산을 수행해야합니다. 이를 대체하기 위해 React는 두 가지 가정을 기반하여 O(n) 복잡도의 휴리스틱 알고리즘을 구현했습니다.</p><ol><li>서로 다른 타입의 두 엘리먼트는 서로 다른 트리를 만들어낸다.</li><li>개발자가 <code>key</code> prop을 통해, 여러 렌더링 사이에서 어떤 자식 엘리먼트가 변경되지 않아야 할지 표시해 줄 수 있다.</li></ol><p>실제로 거의 모든 사용 사례에서 이 가정들은 들어맞습니다.</p><h2><a href="https://github.com/kooku0/kooku-s-log/blob/main/content/blog/react/react-reconciliation-%26-fiber.md#%EB%B9%84%EA%B5%90-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-diffing-algorithm"></a>비교 알고리즘 (Diffing Algorithm)</h2><p>두 개의 트리를 비교할 때, React는 두 엘리먼트의 루트(root) 엘림먼트부터 비교합니다. 이후의 동작은 루트 엘리먼트 타입에 따라 달라집니다.</p><h3><a href="https://github.com/kooku0/kooku-s-log/blob/main/content/blog/react/react-reconciliation-%26-fiber.md#%EC%97%98%EB%A6%AC%EB%A8%BC%ED%8A%B8%EC%9D%98-%ED%83%80%EC%9E%85%EC%9D%B4-%EB%8B%A4%EB%A5%B8-%EA%B2%BD%EC%9A%B0"></a>엘리먼트의 타입이 다른 경우</h3><p>두 루트 엘리먼트의 타입이 다르면, React는 이전 트리를 버리고 완전히 새로운 트리를 구축합니다. <code>&lt;a&gt;</code> 에서 <code>&lt;img&gt;</code>로 바뀌는 등 트리 전체를 재구축하는 경우입니다.</p><p>트리를 버릴 때 이전 DOM 노드들은 모두 파괴됩니다. 컴포넌트 인스턴스는 <code>componentWillUnmount()</code>가 실행됩니다. 새로운 트리가 만들어 질 때, 새로운 DOM 노드들이 DOM에 삽입됩니다. 그에 따라 컴포넌트 인스턴스는 <code>componentDidWillMount()</code>가 실행됩니다. 이전 트리와 연관된 모든 state는 사라집니다.</p><p>루트 엘리먼트 아래의 모든 컴포넌트도 언마운트되고 그 state도 사라집니다. 예를 들어, 아래와 같은 비교가 일어나면,</p><pre><code class="language-jsx">&lt;div&gt;
  &lt;Counter /&gt;
&lt;/div&gt;

&lt;span&gt;
  &lt;Counter /&gt;
&lt;/span&gt;
</code></pre><p>이전 <code>Counter</code>는 사라지고, 새로 다시 마운트가 될 것입니다.</p><h3><a href="https://github.com/kooku0/kooku-s-log/blob/main/content/blog/react/react-reconciliation-%26-fiber.md#dom-%EC%97%98%EB%A6%AC%EB%A8%BC%ED%8A%B8%EC%9D%98-%ED%83%80%EC%9E%85%EC%9D%B4-%EA%B0%99%EC%9D%80-%EA%B2%BD%EC%9A%B0"></a>DOM 엘리먼트의 타입이 같은 경우</h3><p>같은 타입의 두 React DOM 엘리먼트를 비교할 때, React는 두 엘리먼트의 속성을 확인하여, 동일한 내역은 유지하고 변경된 속성들만 갱신합니다. 예를 들어,</p><pre><code class="language-html">&lt;div className=&quot;before&quot; title=&quot;stuff&quot; /&gt;

&lt;div className=&quot;after&quot; title=&quot;stuff&quot; /&gt;
</code></pre><p>이 두 엘리먼트를 비교하면, React는 현재 DOM 노드 상에 <code>className</code>만 수정합니다.</p><p><code>style</code>이 갱신될 때, React는 또한 변경된 속성만을 갱신합니다. 예를 들어,</p><pre><code class="language-jsx">&lt;div style={{color: &#x27;red&#x27;, fontWeight: &#x27;bold&#x27;}} /&gt;

&lt;div style={{color: &#x27;green&#x27;, fontWeight: &#x27;bold&#x27;}} /&gt;
</code></pre><p>위 두 엘리먼트 사이에서 변경될 때, <code>fontWeight</code>는 수정하지 않고 <code>color</code>속성 만을 수정합니다.</p><p>DOM 노드의 처리가 끝나면, React는 이어서 해당 노드의 자식들을 재귀적으로 처리합니다.</p><h2><a href="https://github.com/kooku0/kooku-s-log/blob/main/content/blog/react/react-reconciliation-%26-fiber.md#%EC%9E%90%EC%8B%9D%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9E%AC%EA%B7%80%EC%A0%81-%EC%B2%98%EB%A6%AC"></a>자식에 대한 재귀적 처리</h2><p>DOM 노드의 자식들을 재귀적으로 처리할 때, React는 기본적으로 동시에 두 리스트를 순회하고 차이점이 있으면 변경을 생성합니다.</p><p>예를 들어, 자식의 끝에 엘리먼트를 추가하면, 두 트리 사이의 변경은 잘 작동할 것입니다.</p><pre><code class="language-jsx">&lt;ul&gt;
  &lt;li&gt;first&lt;/li&gt;
  &lt;li&gt;second&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;
  &lt;li&gt;first&lt;/li&gt;
  &lt;li&gt;second&lt;/li&gt;
  &lt;li&gt;third&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>React는 두 트리에서 <code>&lt;li&gt;first&lt;/li&gt;</code>가 일치하는 것을 확인하고, <code>&lt;li&gt;second&lt;/li&gt;</code>가 일치하는 것을 확인합니다. 그리고 마지막으로 <code>&lt;li&gt;third&lt;/li&gt;</code>를 트리에 추가합니다.</p><p>하지만 위와 같이 단순하게 구현하면, 트리의 맨 앞에 엘리먼트를 추가하는 경우 성능이 좋지 않습니다. 예를 들어, 아래의 두 트리 변환은 형편없이 작동합니다.</p><pre><code class="language-jsx">&lt;ul&gt;
  &lt;li&gt;Duke&lt;/li&gt;
  &lt;li&gt;Villanova&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;
  &lt;li&gt;Connecticut&lt;/li&gt;
  &lt;li&gt;Duke&lt;/li&gt;
  &lt;li&gt;Villanova&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>React는 <code>&lt;li&gt;Duke&lt;/li&gt;</code>와 <code>&lt;li&gt;Villanova&lt;/li&gt;</code> 종속 트리를 그대로 유지하는 대신 모든 자식을 변경합니다. 이러한 비효율은 문제가 될 수 있습니다.</p><h3><a href="https://github.com/kooku0/kooku-s-log/blob/main/content/blog/react/react-reconciliation-%26-fiber.md#keys"></a>Keys</h3><p>이러한 문제를 해결하기 위해, React는 <code>key</code> 속성을 지원합니다. 자식들이 key를 가지고 있다면, React는 key를 통해 기존 트리와 이후 트리의 자식들이 일치하는지 확인합니다. 예를 들어, 위 비효율적인 예시에 <code>key</code>를 추가하여 트리의 변환 작업이 효율적으로 수행되도록 수정할 수 있습니다.</p><pre><code class="language-jsx">&lt;ul&gt;
  &lt;li key=&quot;2015&quot;&gt;Duke&lt;/li&gt;
  &lt;li key=&quot;2016&quot;&gt;Villanova&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;
  &lt;li key=&quot;2014&quot;&gt;Connecticut&lt;/li&gt;
  &lt;li key=&quot;2015&quot;&gt;Duke&lt;/li&gt;
  &lt;li key=&quot;2016&quot;&gt;Villanova&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>이를 위해 데이터 구조에 ID라는 속성을 추가해주거나 데이터 일부에 해시를 적용해서 key를 생성할 수 있습니다. 해당 key는 오로지 형제 사이에서만 유일하면 되고, 전역에서 유일할 필요는 없습니다.</p><p>최후의 수단으로 배열의 인덱스를 key로 사용할 수 있습니다. 만약 항목들이 재배열되지 않는다면 이 방법도 잘 동작할 것이지만, 재배열되는 경우 비효율적으로 동작할 것입니다.</p><p>인덱스를 key로 사용 중 배열이 재배열되면 컴포넌트의 state와 관련된 문제가 발생할 수 있습니다. 컴포넌트 인스턴스는 key를 기반으로 갱신되고 재사용됩니다. 인덱스를 key로 사용하면, 항목의 순서가 바뀌었을 때 key 또한 바뀔 것입니다. 그 결과로, 컴포넌트의 state가 엉망이 되거나 의도하지 않은 방식으로 바뀔 수도 있습니다.</p><h1><a href="https://github.com/kooku0/kooku-s-log/blob/main/content/blog/react/react-reconciliation-%26-fiber.md#react-fiber"></a>React Fiber</h1><p>React Fiber는 React v16에 포함된 새로운 reconciliation algorithm 입니다.</p><p>React&#x27;s core algorithm을 대부분 갈아엎은 2년 이상의 연구로 만들어진 알고리즘으로 React Fiber의 목표는 animation, layout, gestures와 같은 영역에 대한 rendering을 향상시키는 것 입니다.</p><p>주요 특징은 <strong>incremental rendering</strong>으로 rendering work를 덩어리로 쪼갠 후 여러 프레임에서 적절히 수행시키는 것 입니다.</p><p>주요 포인트는 다음과 같습니다.</p><ul><li>UI에서 모든 업데이트를 즉시 적용할 필요가 없다. 실제로 그렇게 하면 frame drop과 사용자 경험이 저하될 수 있다.</li><li>업데이트마다 우선순위가 다르다. 애니메이션은 data update 보다 더 빨리 완료되어야한다.</li></ul><h2><a href="https://github.com/kooku0/kooku-s-log/blob/main/content/blog/react/react-reconciliation-%26-fiber.md#what-is-fiber"></a>What is fiber?</h2><p>UI를 다룰 때, 너무 많은 작업이 한 번에 실행될 때 문제가 생기기 마련입니다. 이럴 때 animation을 수행하게 되면 frame drop 과 사용자에게 툭툭 끊기게 보여지게 됩니다.</p><p>이를 해결하기 위해 작업들에 대해 우선순위를 매기고 <code>requestIdleCallback</code>은 유휴 기간 동안 낮은 우선순위 함수를 호출하도록 예약하고 <code>requestAnimationFrame</code>은 다음 animation에서 호출할 높은 우선 순위 함수를 예약하면 됩니다. 하지만 이러한 API를 사용하기 위해서는 <strong>Incremental rendering</strong>이 필요합니다. rendering 과정에는 단 하나의 call stack에만 사용하기에 스택이 비워질 때까지 다른 작업을 수행하지 않기 때문입니다.</p><p>UI rendering을 최적화하기 위해 call stack의 동작을 사용자 마음대로 정의할 수 있다면 좋지 않을까요? call stack을 마음대로 중단하고 stack frame을 수동으로 조작할 수 있다면 좋지 않을까요? 이것이 React Fiber의 목적입니다. Fiber는 React 컴포넌트에 특화된 stack의 재구현으로 <strong>virtual stack frame</strong>으로 생각하면 됩니다.</p><h2><a href="https://github.com/kooku0/kooku-s-log/blob/main/content/blog/react/react-reconciliation-%26-fiber.md#incremental-rendering"></a>Incremental rendering</h2><ul><li>pause work and come back to it later</li><li>assign priority to different types of work</li><li>reuse previously completed work</li><li>abort work if it&#x27;s no longer needed</li></ul><p>Fiber에서는 <code>requestIdleCallback</code>을 활용해서 동작중인 React 코드를 매번 부르고, 주어진 시간을 초과한다면 멈추고 더 중요한 일에 양보합니다. 더 중요한 일이 끝나면 다시 돌아와서 나머지 작업을 완료합니다.</p><p>어느 시점에서나 작업을 멈출 수 있어야 한다는 것은 task가 잘게 쪼개질 수 있어야 가능해 보입니다. 그리고 이러한 작업이 Incremental task 입니다.</p><h1><a href="https://github.com/kooku0/kooku-s-log/blob/main/content/blog/react/react-reconciliation-%26-fiber.md#phases"></a>Phases</h1><h2><a href="https://github.com/kooku0/kooku-s-log/blob/main/content/blog/react/react-reconciliation-%26-fiber.md#phase-1-render--reconciliation"></a>Phase 1 (render / reconciliation)</h2><p>interrupible</p><h2><a href="https://github.com/kooku0/kooku-s-log/blob/main/content/blog/react/react-reconciliation-%26-fiber.md#phase-2-commit"></a>Phase 2 (commit)</h2><p>no interruptible</p><h2><a href="https://github.com/kooku0/kooku-s-log/blob/main/content/blog/react/react-reconciliation-%26-fiber.md#reference"></a>Reference</h2><ul><li><a href="https://ko.reactjs.org/docs/reconciliation.html">react - reconciliation</a></li><li><a href="https://www.youtube.com/watch?v=ZCuYPiUIONs">Lin Clark - A Cartoon Intro to Fiber - React Conf 2017</a></li><li><a href="https://github.com/acdlite/react-fiber-architecture">react-fiber-architecture</a></li></ul>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Third-party JavaScript performance]]></title>
        <id>Third-party JavaScript performance</id>
        <link href="https://kooku0.gihub.io/blog/third-party-javascript-performance-with-script-async-defer"/>
        <updated>2021-04-04T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Web.dev의 Efficiently load third-party JavaScript를 참고하여 작성하였습니다.]]></summary>
        <content type="html"><![CDATA[<blockquote><p>Web.dev의 <a href="https://web.dev/efficiently-load-third-party-javascript/">Efficiently load third-party JavaScript</a>를 참고하여 작성하였습니다.</p></blockquote><p>Third-party script 가 페이지의 로드를 느리게 할 경우, 성능을 향상시키기 위한 두가지 옵션이 있습니다.</p><ul><li>사이트에 명백한 가치를 주지않다면 제거해라.</li><li>loading process를 최적화 시켜라</li></ul><p>loading progess를 최적화시키는 방법으로는 다음과 같은 방법들이 있습니다.</p><ol><li><code>&lt;script&gt;</code> 태그에 <code>async</code> 또는 <code>defer</code> attribute를 사용</li><li>필요한 origins에 미리 connections을 시켜놓기</li><li>Lazy-loading</li><li>third-party scripts serving을 최적화</li></ol><p>이번 포스팅에는 1번 방법만 설명하도록 하겠습니다.</p><h2>Use async or defer</h2><p>Synchronous scripts는 DOM Pharsing을 막아 rendering을 지연시키기에, third-party scripts의 로드는 항상 비동기적으로 실행시켜야하며 page가 render되기 전에 script를 실행시킬 필요가 없습니다.</p><p><code>async</code>와 <code>defer</code> 속성은 브라우저에게 HTML이 parsing되는 중에 background에서 script를 로드하고 load가 된 후에 script를 실행시킨다고 말해줍니다. 이러한 방법으로 script download는 DOM 생성과 rendering을 block하지 않습니다. 이러한 방법으로 user는 모든 스크립트가 로드되기 전에 page를 볼 수 있습니다.</p><pre><code class="language-html">&lt;script async src=&quot;script.js&quot;&gt;

&lt;script defer src=&quot;script.js&quot;&gt;
</code></pre><p><code>async</code>와 <code>defer</code>의 차이점은 scripts의 실행 시점에 차이가 있습니다.</p><h3>async</h3><p><code>async</code> 속성을 가진 Sscript는 download를 마친 후 window&#x27;s의 load event 전에 실행시킵니다. 이는 비동기 스크립트가 HTML에 나타나는 순서대로 실행되지 않을 가능성이 있다는 것을 의미합니다. 또한 DOM tree 생성을 하고 있는 도중 script 다운로드가 완료되면 DOM tree 생성을 interrupt 할 수도 있습니다.</p><p><img src="../images/async.png"/></p><h3>defer</h3><p><code>defer</code> 속성을 가진 scripts는 HTML parsing이 완료된 이후, DOMContentLoaded 이벤트 이전에 실행됩니다. <code>defer</code>는 HTML이 순서대로 실행되는 것을 보장하고 parsing을 block하지 않습니다.</p><p><img src="../images/defer.png"/></p><ul><li><code>async</code>는 load process 초기에 스크립트를 실행시키는 것이 중요할 때 사용합니다.</li><li><code>defer</code>는 덜 중요한 요소에 사용하는 것이 좋습니다. 예를 들어 스크롤을 해야 볼 수 있는 동영상 플레이어.</li></ul><h3>Code</h3><p>실제 코드에서 이론대로 동작하는지 확인해보겠습니다.</p><pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;ko&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;

    &lt;script defer src=&quot;./defer.js&quot;&gt;&lt;/script&gt;
    &lt;script async src=&quot;./async.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;./sample.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      console.log(&quot;in head&quot;);
      window.addEventListener(&quot;DOMContentLoaded&quot;, function () {
        console.log(&quot;DOMContentLoaded is loaded&quot;);
      });

      window.onload = function () {
        console.log(&quot;window is loaded&quot;);
      };
    &lt;/script&gt;
    &lt;title&gt;React App&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;
    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
    &lt;script&gt;
      console.log(&quot;end of body&quot;);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>다음과 같은 코드가 있다고 했을 때 콘솔에는 다음과 같이 찍혔고 생각했던 대로 동작함을 확인할 수 있었습니다.</p><pre><code>async
in sample
in head
end of body
defer
DOMContentLoaded is loaded
window is loaded
</code></pre><h2>마무리</h2><p>실제 프로젝트를 하면서 third-party javascript library를 사용하는 경우가 많습니다. kakao-sdk, google-analytics, google tag manager, facebook-sdk, etc... 이러한 라이브러리를을 아무렇게나 사용하게 되면 First Paint가 늦어져 사용자 입장에서는 페이지 로딩이 느린, 안좋은 경험을 할 수 있습니다. 이러한 문제들은 script 태그에 <code>async</code>, <code>defer</code> 속성을 적절히 사용함으로써 해결할 수 있습니다.</p>]]></content>
    </entry>
</feed>