---
title: 1. 단위 테스트의 목표
---

단위 테스트에 시간을 투자할 때는 항상 최대한 이득을 얻도록 노력해야하며, 테스트에 드는 노력을 가능한 한 줄이고 그에 따르는 이득을 최대화해야 한다. 

이러한 균형을 달성한 프로젝트를 살펴보는 것도 매우 흥미롭다. 무난하게 성장하고 유지 보수가 많이 필요하지 않으며 끊임없이 변화하는 고객의 요구에 신속히 대응할 수 있는 프로젝트다. 노력을 많이 들이고 단위 테스트를 매우 많이 작성하더라도 많은 버그와 유지비로 프로젝트 진행이 느려지게 된다.

## 1.1. 단위 테스트 현황

단위 테스트를 적용해야 하는지는 더 이상 논쟁거리가 아니다. 그냥 쓰고 버리는 프로젝트가 아니면, 단위 테스트는 늘 적용해야 한다. 

많은 프로젝트에 자동화된 테스트가 있고, 심지어 테스트도 많다. 그러나 테스트가 있어요 개발자들이 원하는 결과를 얻지 못하는 경우가 많다. 프로그래머들은 이러한 프로젝트를 수행하는 데 많은 노력이 필요할 수 있다. 새로운 기능을 구현하는 데 오래 걸리고, 이미 구현되고 반영된 기능에 새로운 버그가 지속적으로 나타나며, 도움을 약속했던 단위 테스트는 이러한 상황을 전혀 완화하지 못한 듯하다.

좋은 테스트와 좋지 않은 테스트의 차이는 취향이나 개인적인 선호도의 문제가 아니라 현재 작업 중인 중대한 프로젝트의 성패를 가르는 문제다.

## 1.2. 단위 테스트의 목표

흔히 단위 테스트 활동이 더 나은 설계로 이어진다고 한다. 이는 사실이다. 하지만 단위 테스트의 주목표는 아니다. 더 나은 설계는 단지 좋은 사이드 이펙트일 뿐이다.

:::note 단위 테스트와 코드 설계의 관계

코드를 단위 테스트하기 어렵다면 코드 개선이 반드시 필요하다는 것을 의미한다. 보통 강결합(tight coupling)에서 저품질이 나타나는데, 여기서 강결합은 제품 코드가 서로 충분히 분리되지 않아서 따로 테스트하기 어려움을 뜻한다.

코드베이스를 쉽게 단위 테스트할 수 있다고 해도 반드시 코드 품질이 좋은 것을 의미하지는 않는다. 낮은 결합도를 보여도 프로젝트는 '대참사'가 될 수 있다.

:::

그럼 단위 테스트의 목표는 무엇인가? 소프트웨어 프로젝트의 지속 가능한 성장을 가능하게 하는 것이다. 지속 가능하다는 것이 핵심이다. 프로젝트가 상당히 쉽게 성장할 수 있다. 특히 처음부터 시작할 때 그렇다. 하지만 시간이 지나면서 이렇게 계속 성장하기는 훨씬 어렵다.

테스트가 없는 일반 프로젝트의 성장 추이는 다음과 같다. 처음에는 발목을 잡을 것이 없으므로 빨리 시작할 수 있다. 아직 잘못된 아키텍처 결정이 없고, 걱정할 만한 코드가 있지도 않다. 그러나 시간이 지나면서 점점 더 많은 시간을 들여야 처음에 보여준 것과 같은 정도의 진척을 낼 수 있다. 결국 개발 속도가 현저히 느려지고, 심지어 전혀 진행하지 못할 정도로 느려질 수도 있다.

개발 속도가 빠르게 감소하는 이러한 현상을 소프트웨어 엔트로피라고도 한다.

소프트웨어에서 엔트로피는 품질을 떨어뜨리는 코드 형태로 나타난다. 코드베이스에서 무언가를 변경할 때마다 무질서도는 증가한다. 지속적인 정리와 리팩터링 등과 같은 적절한 관리를 하지 않고 방치하면 시스템이 점점 더 복잡해지고 무질서해진다. 하나의 버그를 수정하면 더 많은 버그를 양산하고, 소프트웨어의 한 부분을 수정하면 다른 부분들이 고장 난다.

테스트로 이러한 경향을 뒤집을 수 있다. 테스트는 안전망 역할을 하며 대부분의 회귀에 대한 보험을 제공하는 도구라 할 수 있다. 테스트는 새로운 기능을 도입하거나 새로운 요구 사항에 더 잘 맞게 리팩터링한 후에도 기존 기능이 잘 동작하는지 확인하는 데 도움이 된다.

:::info

회귀는 특정 사건 후에 기능이 의도한 대로 작동하지 않는 경우다. 소프트웨어 버그와 회귀라는 용어는 동의어이며 바꿔서 사용할 수 있다.

:::

여기서 한 가지 단점을 생각해볼 수 있는데, 이러한 테스트는 초반에 노력이 필요하다는 것이다. 그러나 프로젝트 후반에도 잘 성장할 수 있도록 하므로 장기적으로 보면 그 비용을 메울 수 있다. 코드베이스를 지속적으로 검증하는 테스트 없이는 소프트웨어 개발이 쉽게 확장되지 않는다.

지속성과 확장성이 핵심이며, 이를 통해 장기적으로 개발 속도를 유지할 수 있다.

### 1.2.1 좋은 테스트와 좋지 않은 테스트를 가르는 요인

단위 테스트가 프로젝트 성장에 도움이 되는 것은 맞지만, 테스트를 작성하는 것만으로는 충분하지 않다. 잘못 작성한 테스트는 여전히 같은 결과를 낳는다. 이러한 프로젝트가 침체 단계에 진입하는데 시간이 더 걸릴 수 있지만, 피할 수는 없다.

모든 테스트를 작성할 필요는 없다. 일부 테스트는 아주 중요하고 소프트웨어 품질에 매우 많은 기여를 한다. 그 밖에 다른 테스트는 그렇지 않다. 잘못된 경고가 발생하고, 회귀오류를 알아내는 데 도움이 되지 않으며, 유지 보수가 어렵고 느리다. 프로젝트에 도움이 되는지 여부를 명확하게 파악하지 않고 단위 테스트를 작성하는 데만 빠져들기 쉽다.

단지 프로젝트에서 테스트를 더 많이 쏟아내도 단위 테스트의 목표를 달성할 수 없다. 테스트의 가치와 유지 비용을 모두 고려해야 한다. 비용 요소는 다양한 활동에 필요한 시간에 따라 결정된다.
- 기반 코드를 리팩터링할 때 테스트도 리팩터링하라.
- 각 코드 변경 시 테스트를 실행하라.
- 테스트가 잘못된 경고를 발생시킬 경우 처리하라.
- 기반 코드가 어떻게 동작하는지 이해하려고 할 때는 테스트를 읽는 데 시간을 투자하라.
지속 가능한 프로젝트 성장을 위해서는 고품질 테스트에만 집중해야 한다.

:::note 제품 코드 대 테스트 코드

사람들은 종종 제품 코드와 테스트 코드가 다르다고 생각한다. 테스트는 제품 코드에 추가된 것으로 간주되며 소유 비용이 없다. 또한 사람들은 종종 테스트가 많으면 많을 수록 좋다고 생각한다. 하지만 그렇지 않다. 코드는 자산이 아니라 책임이다. 코드가 더 많아질수록, 소프트웨어 내의 잠재적인 버그에 노출되는 표면적이 더 넓어지고 프로젝트 유지비가 증가한다. 따라서 가능한 한 적은 코드로 문제를 해결하는 것이 좋다.

테스트도 역시 코드다. 특정 문제를 해결하는 것, 즉 애플리케이션의 정확성을 보장하는 것을 목표로 하는 코드베이스의 일부로 봐야 한다. 다른 코드와 마찬가지로 단위 테스트도 버그에 취약하고 유지보수가 필요하다.

:::

## 1.3. 테스트 스위트 품질 측정을 위한 커버리지 지표

가장 널리 사용되는 두 가지 커버리지 지표를 어떻게 계산하고 어떻게 사용하는지 살펴보고 관련된 문제점도 알아본다. 프로그래머가 특정 커버러지 숫자를 목표로 하는 것이 해로운 이유와 테스트 스위트 품질을 결정하는 데 커버리지 지표에 의존할 수 없는 이유를 알아본다.

커버리지 지표는 중요한 피드백을 주더라도 테스트 스위트 품질을 효과적으로 측정하는 데 사용될 수 없다. 코드를 단위 테스트하는 것과 같은 상황이다. 즉, 커버리지 지표는 괜찮은 부정 지표이지만 좋지 않은 긍정 지표다.

코드 커버리지가 너무 적을 때는 테스트가 충분치 않다는 좋은 증거다. 그러나 반대의 경우는 그렇지 못하다. 100% 커버리지라고 해서 반드시 양질의 테스트 스위트라고 보장하지는 않는다. 높은 커버리지의 테스트 스위트도 품질이 떨어질 수 있다.

### 1.3.1 코드 커버리지 지표에 대한 이해

가장 많이 사용되는 커버리지 지표로 코드 커버리지가 있으며, 테스트 커버리지로도 알려져 있다. 이 지표는 하나 이상의 테스트로 실행된 코드 라인 수와 제품 코드베이스의 전체 라인 수의 비율을 나타낸다.

### 1.3.2 분기 커버리지 지표에 대한 이해

분기 커버리지는 코드 커버리지의 단점을 극복하는 데 도움이 되므로 코드 커버리지보다 더 정확한 결과를 제공한다. 분기 커버리지 지표는 원시 코드 라인 수르 사용하는 대신 if 문과 switch 문과 같은 제어 구조에 중점을 둔다. 테스트 스위트 내 하나 이상의 테스트가 통과하는 제어 구조의 수를 나타낸다.

### 1.3.3. 커버리지 지표에 관한 문제점

분기 커버리지로 코드 커버리지보다 더 나은 결과를 얻을 수 있지만, 테스트 스위트의 품질을 결정하는 데 어떤 커버리지 지표도 의존할 수 없는 이유는 다음과 같다.
- 테스트 대상 시스템의 모든 가능한 결과를 검증한다고 보장할 수 없다.
- 외부 라이브러리의 코드 경로를 고려할 수 있는 커버리지 지표는 없다.

#### 가능한 모든 결과를 검증한다고 보증할 수 없음

단지 코드 경로를 통과하는 것이 아니라 실제로 테스트하려면, 단위 테스트에는 반드시 적절한 검증이 있어야 한다. 테스트 대상 시스템이 낸 결과가 정확히 예상하는 결과인지 확인해야 한다. 따라서 커버리지 지표가 의미가 있으려면, 모든 측정 지표를 검증해야 한다.

```java title="예제 1.2 마지막 결과를 기록하는 IsStringLong 버전"
public static bool WasLastStringLong { get; private set; }

public static ool IsStringLong(string int)
{
  bool result = input.Length > 5;
  WasLastStringLong = result; // <- 첫 번째 결과
  return result; // <- 두 번째 결과
}

public void Test()
{
  bool result = IsStringLong("abc");
  Assert.Equal(false, result); // <- 두 번째 결과만 검증
}
```
IsStringLong 메서드에는 이제 값을 반환하는 명시적인 결과와 속성에 새로운 값을 쓰는 암묵적인 결과가 있다. 그리고 두 번째 암묵적인 결과를 검증하지 않더라도 커버리지 지표는 100% 코드 커버리지와 50% 분기 커버리지의 동일한 결과를 보여준다. 보다시피 커버리지 지표는 기반 코드를 테스트했다고 보장할 수 없으며 일부 실행된 것만 보장한다.

이렇게 결과를 부분적으로 테스트한 것보다 더 극단적인 상황은 검증이 전혀 없는 테스트의 경우다.

```java title="예제 1.3 검증이 없는 테스트는 언제나 통과한다."
public void Test()
{
  bool result1 = IsString("abc"); // <-- true 반환
  bool result2 = IsString("abcdef"); // <-- false 반환
}
```

이 테스트에서는 코드 커버리지와 분기 커버리지가 둘 다 100%를 나타내고 있다. 그러나 아무것도 검증하지 않기 때문에 전혀 쓸모가 없다.

#### 외부 라이브러리의 코드 경로를 고려할 수 없음

두 번째 문제는 모든 커버리지 지표가 테스트 대상 시스템이 메서드를 호출할 때 외부 라이브러리가 통과하는 코드 경로를 고려하지 않는다는 것이다. 

```java
public static int Parse(string input)
{
  return int.Parse(input);
}

public void Test()
{
  int result = Parse("5");
  Assert.Equal(5, result);
}
```
분기 커버리지 지표는 100%로 표시되며, 테스트는 메서드 결과의 모든 구성 요소를 검증한다. 하지만 테스트는 완벽하지 않다. int.Parse 메서드가 수행하는 코드 경로를 고려하지 않는다.

이는 커버리지 지표가 외부 라이브러리의 코드 경로를 고려해야 한다는 것이 아니라(고려하면 안 된다.), 해당 지표로는 단위 테스트가 얼마나 좋은지 나쁜지를 판단할 수 없다는 것을 보여준다. 커버리지 지표로 테스트가 철저한지 또는 테스트가 충분한지 알 수는 없다.

### 1.3.4. 특정 커버리지 숫자를 목표로 하기

커버리지 지표를 보는 가장 좋은 방법은 지표 그 자체로 보는 것이며, 목표로 여겨서는 안 된다.

특정 커버리지 숫자를 목표로 하는 것은 단위 테스트의 목표와 반대되는 그릇된 동기 부여가 된다. 커버리지 숫자를 강요하면 개발자들은 테스트 대상에 신경 쓰지 못하고, 결국 적절한 단위 테스트는 더욱 달성하기 어려워진다.

커버리지 지표는 좋은 부정 지표이지만 나쁜 긍정 지표다. 커버리지 숫자가 낮으면 문제 징후라 할 수 있다. 코드베이스에 테스트되지 않은 코드가 많다는 뜻이다. 그러나 높은 숫자도 별 의미는 없다.

## 1.4. 무엇이 성공적인 테스트 스위트를 만드는가?

성공적인 테스트 스위트는 다음과 같은 특성을 갖고 있다.
- 개발 주기에 통합돼 있다.
- 코드베이스에서 가장 중요한 부분만을 대상으로 한다.
- 최소한의 유지비로 최대의 가치를 끌어낸다.

### 1.4.1. 개발 주기에 통합돼 있음

자동화된 테스트를 할 수 있는 방법은 끊임없이 하는 것 뿐이다. 모든 테스트는 개발 주기에 통합돼야 한다. 이상적으로는 코드가 변경될 때마다 아무리 작은 것이라도 실행돼야 한다.

### 1.4.2. 코드베이스에서 가장 중요한 부분만을 대상으로함

단위 테스트 측면에서 코드베이스의 모든 부분에 똑같이 주목할 필요는 없다. 테스트가 주는 가치는 테스트 구조뿐만 아니라 검증하는 코드에도 있다.

시스템의 가장 중요한 부분에 단위 테스트 노력을 기울이고, 다른 부분은 간략하게 또는 간접적으로 검증하는 것이 좋다. 대부분의 애플리케이션에서 가장 중요한 부분은 비즈니스 로직이 있는 부분이다. 비즈니스 로직 테스트가 시간 투자 대비 최고의 수익을 낼 수 있다.

다른 모든 부분은 세 가지 범주로 나눌 수 있다.
- 인프라 코드
- 데이터베이스나 서드파티 시스템과 같은 외부 서비스 및 종속성
- 모든 것을 하나로 묶는 코드

통합 테스트와 같이 일부 테스트는 도메인 모델을 넘어 코드베이스의 중요하지 않은 부분을 포함해 시스템이 전체적으로 어떻게 작동하는지 확인할 수 있다. 그러나 초점은 도메인 모델에 머물러 있어야 한다.

이 지침을 따르려면 도메인 모델을 코드베이스 중 중요하지 않은 부분과 분리해야 한다. 도메인 모델을 다른 애플리케이션 문제와 분리해야 단위 테스트에 대한 노력을 도메인 모델에만 집중할 수 있다.

### 1.4.3. 최소 유지비로 최대 가치를 끌어냄

단위 테스트에서 가장 어려운 부분은 최소 유지비로 최대 가치를 달성하는 것이다.

테스트를 빌드 시스템에 통합하는 것만으로는 충분하지 않으며, 도메인 모델에 높은 테스트 커버리지를 유지하는 것도 충분하지 않다. 또한 가치가 유지비를 상회하는 테스트만 스위트에 유지하는 것이 중요하다.

이 마지막 속성은 두 가지로 나눌 수 있다.
- 가치 있는 테스트 식별하기
- 가치 있는 테스트 작성하기

가치가 높은 테스트를 식별하려면 기준틀이 필요하다. 반면에 가치 있는 테스트를 작성하려면 코드설계 기술도 알아야 한다. 단위 테스트와 기반 코드는 서로 얽혀 있으므로 코드베이스에 노력을 많이 기울이지 않으면 가치 있는 테스트를 만들 수 없다.

## 1.5. 이 책을 통해 배우는 것

이 책을 통해 테스트 스위트 내의 모든 테스트를 분석하는 데 사용할 수 있는 기준틀을 설명한다.

기초를 다진 후, 기존 단위 테스트 기술과 실천을 살펴본다. 이런 기술과 실천에 익숙한지 여부는 상관없다. 익숙하다면 새로운 각도에서 보게 될 것이다.

이 책에서는 테스트 스위트 내의 모든 테스트를 분석하는 데 사용할 수 있는 기준틀 외에 다음 내용도 다룬다.
- 제품 코드와 관련된 테스트 스위트를 리팩터링하는 방법
- 단위 테스트를 다양한 스타일로 적용하는 방법
- 통합 테스트로 시스템 전체 동작 검증하기
- 단위 테스트 안티 패턴을 식별하고 예방하기

이 책에서 단위 테스트 외에도 자동화된 테스트의 전체 주제를 다루기 때문에 통합 테스트와 엔드 투 엔드 테스트에 대해서도 알 수 있다.

## 요약

- 코드는 점점 나빠지는 경향이 있다. 코드베이스에 변경이 생길 때마다 무질서도, 즉 엔트로피가 증가한다. 지속적인 정리와 리팩터링 등과 같은 적절한 관리가 없으면 시스템은 점점 더 복잡해지고 흐트러진다. 테스트로 이러한 경향을 뒤집을 수 있다. 테스트는 안전망 역할을 하며, 대부분의 회귀에 대한 보험을 제공하는 도구라 할 수 있다.
- 단위 테스트를 작성하는 것이 중요하다. 마찬가지로 좋은 단위 테스트를 작성하는 것도 중요하다. 잘못된 테스트를 가졌거나 테스트 자체가 없는 프로젝트는 모두 똑같이 침체 단계에 있거나 매 릴리스마다 회귀가 많이 생긴다.
- 단위 테스트의 목표는 소프트웨어 프로젝트가 지속적으로 성장하게 하는 것이다. 좋은 단위 테스트 스위트는 개발 속도를 지키면서 침체 단계에 빠지지 않게 한다. 이러한 테스트 스위트가 있다면 변경 사항이 회귀로 이어지지 않을 것이라고 확신해도 좋다. 이렇게 하면 코드를 리팩터링하거나 새로운 기능을 추가하는 것이 더 쉬워진다.
- 각각의 테스트는 비용과 편익 요소가 있으며, 둘 다 신중하게 따져볼 필요가 있다. 테스트 스위트 내에 가치 있는 테스트만 남기고 나머지는 모두 제거하라. 애플리케이션과 테스트 코드는 모두 자산이 아니라 부채다.
- 단위 테스트 코드 기능은 좋은 부정 지표(단위 테스트를 할 수 없는 코드는 품질이 좋지 않음)이지만 나쁜 긍정 지표(단위 테스트를 할 수 없다고 품질을 보증하지는 않음)이기도 하다.
- 커버리지 지표는 좋은 부정 지표이지만 나쁜 긍정 지표다. 커버리지가 낮다는 것은 문제의 징후이지만, 커버리지가 높다고 해서 테스트 스위트의 품질이 높은 것은 아니다.
- 분기 커버리지로 테스트 스위트의 완전성에 대해 더 나은 인사이트를 얻을 수 있지만 테스트 스위트가 충분한지는 여전히 알 수 없다. 검증문이 있는지 신경 쓰지 않고, 코드베이스가 사용하는 서드파티 라이브러리의 코드 경로도 다루지 않는다.
- 특정 커버리지 숫자를 부과하면 동기 부여가 잘못된 것이다. 시스템의 핵심 부분에 커버리지를 높게 갖는 것은 좋지만, 이 높은 수준을 요건으로 삼는 것은 좋지 않다.
- 성공적인 테스트 스위트는 다음과 같은 특성을 나타낸다.
  - 개발 주기에 통합돼 있다.
  - 코드베이스 중 가장 중요한 부분만을 대상으로 한다.
  - 최소한의 유지비로 최대의 가치를 끌어낸다.
- 단위 테스트의 목표를 달성하기 위한 유일한 방법은 다음과 같다.
  - 좋은 테스트와 좋지 않은 테스트를 구별하는 방법을 배운다.
  - 테스트를 리팩터링해서 더 가치 있게 만든다.
