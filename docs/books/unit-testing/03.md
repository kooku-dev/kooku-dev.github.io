---
title: 3. 단위 테스트 구조
---

:::info 3장에서 다루는 내용

- 단위 테스트 구조
- 좋은 단위 테스트 명명법
- 매개변수화된 테스트 작성
- Fluent Assertions 사용

:::

## 3.1. 단위 테스트를 구성하는 방법

준비, 실행, 검증 패턴을 사용해 단위 테스트를 구성하는 방법, 피해야 할 함정 그리고 테스트를 가능한 한 읽기 쉽게 만드는 방법 등을 알아본다.

### 3.1.1. AAA 패턴 사용

AAA 패턴은 각 테스트를 준비, 실행, 검증이라는 세 부분으로 나눌 수 있다. 

```java
public class Calculator
{
  public double Sum(double first, double second)
  {
    return first + second;
  }
}
```

```java title="예제 3.1 calculator 내 Sum 메서드를 다루는 테스트"
public class CalculatorTests
{
  // [Fact]
  public void Sum_of_two_number()
  {
    // 준비
    double first = 10;
    double second = 20;
    var calculator = new Calculator();

    // 실행
    double result = calculator.Sum(first, second);

    // 검증
    Assert.Equal(30, result);
  }
}
```

AAA 패턴은 스위트 내 모든 테스트가 단순하고 균일한 구조를 갖는 데 도움이 된다. 이러한 일관성이 이 패턴의 가장 큰 장점 중 하나다. 익숙해지면 모든 테스트를 쉽게 읽을 수 있고 이해할 수 있다. 결국 전체 테스트 스위트의 유지 보수 비용이 줄어든다. 구조는 다음과 같다.
- 준비 구절에서는 테스트 대상 시스템과 해당 의존성을 원하는 상태로 만든다.
- 실행 구절에서는 SUT에서 메서드를 호출하고 준비된 의존성을 전달하며 출력 값을 캡처한다.
- 검증 구절에서는 결과를 검증한다. 결과는 반환 값이나 SUT와 협력자의 최종 상태, SUT가 협력자에 호출한 메서드 등으로 표시될 수 있다.

:::note Given-When-Then 패턴

AAA와 유사한 Given-When-Then 패턴에 대해 들어봤을 것이다. 이 패턴도 테스트를 세 부분으로 나눈다.
- Given - 준비 구절에 해당
- When - 실행 구절에 해당
- Then - 검증 구절에 해당
테스트 구성 측면에서 두 가지 패턴 사이에 차이는 없다. 유일한 차이점은 프로그래머가 아닌 사람에게 Given-When-Then 구조가 더 읽기 쉽다는 것이다. 

:::

테스트를 작성할 때는 준비 구절부터 시작하는 것이 자연스럽다. 그다음 다른 두 구절을 작성한다. 이 방법은 대부분의 경우에 효과적이지만 검증 구절로 시작하는 것도 가능한 옵션이다. TDD를 실천할 때, 즉 기능을 개발하기 전에 실패할 테스트를 만들 때는 아직 기능이 어떻게 동작할지 충분히 알지 못한다. 따라서 먼저 기대하는 동작으로 윤곽을 잡은 다음, 이러한 기대에 부응하기 위한 시스템을 어떻게 개발할지 아는 것이 좋다.

직관적이지는 않지만, 이것이 문제를 해결하는 방식이다. 특정 동작이 무엇을 해야 하는지에 대한 목표를 생각하면서 시작한다. 그 다음이 문제 해결이다. 이 지침은 TDD를 실천할 때만 적용될 수 있다. 테스트 전에 제품 코드를 작성한다면 테스트를 작성할 시점에 실행에서 무엇을 예상하는지 이미 알고 있으므로 준비 구절부터 시작하는 것이 좋다.

### 3.1.2. 여러 개의 준비, 실행, 검증 구절 피하기

따로는 준비, 실행 또는 검증 구절이 여러 개 있는 테스트를 만날 수 있다. 검증 구절로 구분된 여러 개의 실행 구절을 보면, 여러 개의 동작 단위를 검증하는 테스트를 뜻한다. 2장에서 본 바와 같이 이러한 테스트는 더 이상 단위 테스트가 아니라 통합 테스트다. 이러한 테스트 구조는 피하는 것이 좋다. 실행이 하나면 테스트가 단위 테스트 범주에 있게끔 보장하고, 간단하고, 빠르며, 이해하기 쉽다. 일련의 실행과 검증이 포함된 테스트를 보면 리팩터링하라. 각 동작을 고유의 테스트로 도출하라.

통합 테스트에서는 실행 구절을 여러 개 두는 것이 괜찮을 때도 있다. 통합 테스트는 느릴 수 있다. 속도를 높이는 한 가지 방법은 여러 개의 통합 테스트를 여러 실행과 검증이 있는 단일한 테스트로 묶는 것이다. 그러나 이 최적화 기법은 통합 테스트에만 적용할 수 있다. 항상 다단계 단위 테스트를 여러 개의 테스트로 나누는 것이 좋다.

### 3.1.3. 테스트 내 if문 피하기

if 문이 있는 단위 테스튼는 안티 패턴이다. 단위 테스트든 통합 테스트든 테스트는 분기가 없는 간단한 일련의 단계여야 한다. 

if 문은 테스트가 한 번에 너무 많은 것을 검증한다는 표시다. 그러므로 이러한 테스트는 반드시 여러 테스트로 나눠야 한다. 여러 AAA 구절과 달리, 통합 테스트에도 예외는 없다. 테스트에 분기가 있어서 얻는 이점은 없다. 단지 추가 유지비만 불어난다. if 문은 테스트를 읽고 이해하기 어렵게 만든다.

### 3.1.4. 각 구절은 얼마나 커야 하는가?

#### 준비 구절이 가장 큰 경우

일반적으로 준비 구절이 세 구절 중 가장 크다. 그러나 크면 테스트 클래스 내 비공개 메서드 또는 별도의 팩토리 클래스로 도출하는 것이 좋다.

#### 실행 구절이 한 줄 이상인 경우를 경계하라

실행 구절은 보통 코드 한 줄이다. 실행 구절이 두 줄 이상인 경우 SUT의 공개 API에 문제가 있을 수 있다.

```java title="예제 3.2 한 줄로 된 실행 구절"
public void Purchase_succeeds_when_enough_inventory()
{
  // 준비
  var store = new Store();
  store.AddInventory(Product.Shampoo, 10);
  var customer = new Customer();

  // 실행
  bool success = customer.Purchase(store, Product.Shampoo, 5);

  // 검증
  Assert.True(success);
  Assert.Equal(5, store.GetInventory(Product.Shampoo));
}
```

이 실행 구절은 두 줄로 돼 있다. 구매를 마치려면 두 번째 메서드를 호출해야 하므로, 캡슐화가 깨지게 된다.

```java title="예제 3.3 두 줄로 된 실행 구절"
public void Purchase_succeeds_when_enough_inventory()
{
  // 준비
  var store = new Store();
  store.AddInventory(Product.Shampoo, 10);
  var customer = new Customer();

  // 실행
  bool success = customer.Purchase(store, Product.Shampoo, 5);
  store.RemoveInventory(success, Product.Shampoo, 5);

  // 검증
  Assert.True(success);
  Assert.Equal(5, store.GetInventory(Product.Shampoo));
}
```

새 버전의 문제점은 단일 작업을 수행하는 데 두 개의 메서드 호출이 필요하다는 것이다. 테스트 자체는 문제가 되지 않는다. Customer 클래스의 API에 문제가 있으며, 클라이언트에서 메서드 호출을 더 강요해서는 안된다.

비즈니스 관점에서 구매가 정상적으로 이뤄지면 고객의 제품 획득과 매장 재고 감소라는 두 가지 결과가 만들어진다. 이러한 결과는 같이 만들어야 하고, 이는 다시 단일한 공개 메서드에 있어야 한다는 뜻이다. 그렇게 하지 않으면 클라이언트 코드가 첫 번째 메서드를 호출하고 두 번째 메서드를 호출하지 않을 때 모순이 생긴다.

이러한 모순을 불변 위반이라고 하며, 잠재적 모순으로 부터 코드를 보호하는 행위를 캡슐화라고 한다.

실행 구절을 한 줄로 하는 지침은 비즈니스 로직을 포함하는 대부분의 코드에 적용되지만, 유틸리티나 인프라 코드는 덜 적용된다. 그러므로 절대 두 줄 이상 두지 말라고 할 수 없다. 각각의 사례에서 캡슐화 위반이 있을 수 있는지 살펴보자.

### 3.1.5. 검증 구절에는 검증문이 얼마나 있어야 하는가

단위 테스트의 단위는 동작의 단위이지 코드의 단위가 아니다. 단일 동작 단위는 여러 결과를 낼 수 있으며, 하나의 테스트로 그 모든 결과를 평가하는 것이 좋다.

하지만 검증 구절이 너무 커지는 것은 경계해야 한다. 제품 코드에서 추상화가 누락됐을 수 있다. 예를 들어 SUT에서 반환된 객체 내에서 모든 속성을 검증하는 대신 객체 클래스 내에 적절한 동등 맴버를 정의하는 것이 좋다. 그러면 단일 검증문으로 객체를 기대값과 비교할 수 있다.

### 3.1.6. 종료 단계는 어떤가

준비, 실행, 검증 이후의 네 번째 구절로 종료 구절을 따로 구분하기도 한다. 예를 들어 테스트에 의해 작성된 파일을 지우거나 데이터베이스 연결을 종료하고자 이 구절을 사용할 수 있다. 종료는 일반적으로 별도의 메서드로 도출돼 클래스 내 모든 테스트에서 재사용된다. AAA 패턴에는 이 단계를 포함하지 않는다.

대부분의 단위 테스트는 종료 구절이 필요 없다. 단위 테스트는 프로세스 외부에 종속적이지 않으므로 처리해야 할 사이드 이펙트를 남기지 않는다. 종료는 통합 테스트의 영역이다.

### 3.1.7. 테스트 대상 시스템 구별하기

SUT는 테스트에서 중요한 역할을 하는데, 호출하고자 하는 동작에 대한 진입점을 제공한다. 이전 장에서 다뤘듯이, 동작은 여러 클래스에 걸쳐 있을 만큼 클 수도 있고 단일 메서드로 작을 수도 있다. 그러나 진입점은 오직 하나만 존재할 수 있다. 따라서 SUT를 의존성과 구분하는 것이 중요하다. 특히 SUT가 꽤 많은 경우 테스트 대상을 찾는 데 시간을 너무 많이 들일 필요가 없다. 그렇게 하기 위해 테스트 내 SUT 이름을 sut로 하라.

```java title="예제 3.4 의존성과 SUT 구별하기"
public class CalculatorTests
{
  public void Sum_of_two_numbers()
  {
    // 준비
    double first = 10;
    double second = 20;
    var sut = new Calculator();

    // 실행
    double result = sut.Sum(first, second);

    // 검증
    Assert.Equal(30, result);
  }
}
```

### 3.1.8 준비, 실행, 검증 주석 제거하기

의존성에서 SUT를 떼어내는 것이 중요하듯이, 테스트 내에서 특정 부분이 어떤 구절에 속해 있는지 파악하는 데 시간을 많이 들이지 않도록 세 구절을 서로 구분하는 것 역시 중요하다. 이를 위한 한 가지 방법은 각 구절을 시작하기 전에 주석을 다는 것이다. 다른 방법은 빈 줄로 구분하는 것이다.
