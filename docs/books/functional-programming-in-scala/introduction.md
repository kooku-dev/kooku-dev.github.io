---
title: 책 소개
---

## 스칼라로 배우는 함수형 프로그래밍

<img
src={require("./images/book-cover.jpeg").default}
width="300"
alt="book cover"
/>

<table>
  <tr>
    <th>저자</th>
    <td>폴 키우사노 (Paul Chiusano), 루나르 비아르드나손 (Runar Bjarnason) </td>
  </tr>
  <tr>
    <th>옮긴이</th>
    <td>류광</td>
  </tr>
</table>

### 목차

#### 제1부 함수형 프로그래밍 입문

##### 1장 함수형 프로그래밍이란 무엇인가?

- 1.1 FP의 이점: 간단한 예제 하나
- 1.1.1 부수 효과가 있는 프로그램
- 1.1.2 함수적 해법: 부수 효과의 제거
- 1.2 (순수)함수란 구체적으로 무엇인가?
- 1.3 참조 투명성, 순수성, 그리고 치환 모형
- 1.4 요약

##### 2장 스칼라로 함수형 프로그래밍 시작하기

- 2.1 스칼라 언어의 소개: 예제 하나
- 2.2 프로그램의 실행
- 2.3 모듈, 객체, 이름공간
- 2.4 고차 함수: 함수를 함수에 전달
- 2.4.1 잠깐 곁가지: 함수적으로 루프 작성하기
- 2.4.2 첫 번째 고차 함수 작성
- 2.5 다형적 함수: 형식에 대한 추상
- 2.5.1 다형적 함수의 예
- 2.5.2 익명 함수로 고차 함수 호출
- 2.6 형식에서 도출된 구현
- 2.7 요약

##### 3장 함수적 자료구조

- 3.1 함수적 자료구조의 정의
- 3.2 패턴 부합
- 3.3 함수적 자료구조의 자료 공유
- 3.3.1 자료 공유의 효율성
- 3.3.2 고차 함수를 위한 형식 추론 개선
- 3.4 목록에 대한 재귀와 고차 함수로의 일반화
- 3.4.1 그 외의 목록 조작 함수들
- 3.4.2 단순 구성요소들로 목록 함수를 조립할 때의 효율성 손실
- 3.5 트리
- 3.6 요약

##### 4장 예외를 이용하지 않은 오류 처리

- 4.1 예외의 장단점
- 4.2 예외의 가능한 대안들
- 4.3 Option 자료 형식
- 4.3.1 Option의 사용 패턴
- 4.3.2 예외 지향적 API의 Option 합성과 승급, 감싸기
- 4.4 Either 자료 형식
- 4.5 요약

##### 5장 엄격성과 나태성

- 5.1 엄격한 함수와 엄격하지 않은 함수
- 5.2 확장 예제: 게으른 목록
- 5.2.1 스트림의 메모화를 통한 재계산 피하기
- 5.2.2 스트림의 조사를 위한 보조 함수들
- 5.3 프로그램 서술과 평가의 분리
- 5.4 무한 스트림과 공재귀
- 5.5 요약

##### 6장 순수 함수적 상태

- 6.1 부수 효과를 이용한 난수 발생
- 6.2 순수 함수적 난수 발생
- 6.3 상태 있는 API를 순수하게 만들기
- 6.4 상태 동작을 위한 더 나은 API
- 6.4.1 상태 동작들의 조합
- 6.4.2 내포된 상태 동작
- 6.5 일반적 상태 동작 자료 형식
- 6.6 순수 함수적 명령식 프로그래밍
- 6.7 요약

#### 제2부 함수적 설계와 조합기 라이브러리

##### 7장 순수 함수적 병렬성

- 7.1 자료 형식과 함수의 선택
- 7.1.1 병렬 계산을 위한 자료 형식 하나
- 7.1.2 병렬 계산의 조합
- 7.1.3 명시적 분기
- 7.2 표현의 선택
- 7.3 API의 정련
- 7.4 API의 대수
- 7.4.1 map에 관한 법칙
- 7.4.2 fork에 관한 법칙
- 7.4.3 법칙 깨기: 미묘한 버그 하나
- 7.4.4 행위자를 이용한 완전 비차단 Par 구현
- 7.5 조합기들을 가장 일반적인 형태로 정련
- 7.6 요약

##### 8장 속성 기반 검사

- 8.1 속성 기반 검사의 간략한 소개
- 8.2 자료 형식과 함수의 선택
- 8.2.1 API의 초기 버전
- 8.2.2 속성의 의미와 API
- 8.2.3 생성기의 의미와 API
- 8.2.4 생성된 값들에 의존하는 생성기
- 8.2.5 Prop 자료 형식의 정련
- 8.3 검례 최소화
- 8.4 라이브러리의 사용과 사용성 개선
- 8.4.1 간단한 예제 몇 가지
- 8.4.2 병렬 계산을 위한 검사 모음 작성
- 8.5 고차 함수의 검사와 향후 개선 방향
- 8.6 생성기의 법칙들
- 8.7 요약

##### 9장 파서 조합기 라이브러리

- 9.1 대수의 설계: 첫 시도
- 9.2 가능한 대수 하나
- 9.2.1 슬라이싱과 비지 않은 되풀이
- 9.3 문맥 민감성의 처리
- 9.4 JSON 파서 작성
- 9.4.1 JSON 서식
- 9.4.2 JSON 파서
- 9.5 오류 보고
- 9.5.1 가능한 설계 하나
- 9.5.2 오류의 중첩
- 9.5.3 분기와 역추적의 제어
- 9.6 대수의 구현
- 9.6.1 가능한 구현 하나
- 9.6.2 파서들의 순차 실행
- 9.6.3 파서에 이름표 붙이기
- 9.6.4 실패의 극복과 역추적
- 9.6.5 문맥 민감 파싱
- 9.7 요약

#### 제3부 함수적 설계의 공통 구조

##### 10장 모노이드

- 10.1 모노이드란 무엇인가?
- 10.2 모노이드를 이용한 목록 접기
- 10.3 결합법칙과 병렬성
- 10.4 예제: 병렬 파싱
- 10.5 접을 수 있는 자료구조
- 10.6 모노이드 합성
- 10.6.1 좀 더 복잡한 모노이드 합성
- 10.6.2 모노이드 합성을 이용한 순회 융합
- 10.7 요약

##### 11장 모나드

- 11.1 함수자: map 함수의 일반화
- 11.1.1 함수자의 법칙들
- 11.2 모나드: flatMap 함수와 unit 함수의 일반화
- 11.2.1 Monad 특질
- 11.3 모나드적 조합기
- 11.4 모나드 법칙
- 11.4.1 결합법칙
- 11.4.2 특정 모나드의 결합법칙 성립 증명
- 11.4.3 항등법칙
- 11.5 도대체 모나드란 무엇인가?
- 11.5.1 항등 모나드
- 11.5.2 State 모나드와 부분 형식 적용
- 11.6 요약

##### 12장 적용성 함수자와 순회 가능 함수자

- 12.1 모나드의 일반화
- 12.2 Applicative 특질
- 12.3 모나드와 적용성 함수자의 차이
- 12.3.1 적용성 Option과 Option 모나드
- 12.3.2 적용성 Parser 대 Parser 모나드
- 12.4 적용성 함수의 장점
- 12.4.1 모든 적용성 함수자가 모나드는 아니다
- 12.5 적용성 함수자 법칙
- 12.5.1 왼쪽, 오른쪽 항등법칙
- 12.5.2 결합법칙
- 12.5.3 곱의 자연성 법칙
- 12.6 순회 가능 함수자
- 12.7 Traverse의 용도
- 12.7.1 모노이드에서 적용성 함수자로
- 12.7.2 상태 있는 순회
- 12.7.3 순회 가능 구조의 조합
- 12.7.4 순회의 융합
- 12.7.5 중첩된 순회
- 12.7.6 모나드 합성
- 12.8 요약

#### 제4부 효과와 입출력

##### 13장 외부 효과와 입출력

- 13.1 효과의 추출
- 13.2 간단한 입출력 형식
- 13.2.1 입력 효과의 처리
- 13.2.2 단순한 IO 형식의 장단점
- 13.3 StackOverflowError 방지
- 13.3.1 제어의 흐름을 자료 생성자로 구체화
- 13.3.2 트램펄린 적용: 스택 넘침에 대한 일반적 해법
- 13.4 좀 더 정교한 IO 형식
- 13.4.1 자유 모나드
- 13.4.2 콘솔 입출력만 지원하는 모나드
- 13.4.3 순수 해석기
- 13.5 비차단 비동기 입출력
- 13.6 범용 IO 형식
- 13.6.1 그 모든 것의 끝에 있는 주 프로그램
- 13.7 IO 형식이 스트림 방식 입출력에 충분하지 않은 이유
- 13.8 요약

##### 14장 지역 효과와 변이 가능 상태

- 14.1 순수 함수적 변이 가능 상태
- 14.2 부수 효과를 지역 범위로 한정하는 자료 형식
- 14.2.1 범위 있는 변이를 위한 작은 언어
- 14.2.2 변이 가능 참조의 대수
- 14.2.3 변이 가능 상태 동작의 실행
- 14.2.4 변이 가능 배열
- 14.2.5 순수 함수적 제자리 quicksort
- 14.3 순수성은 문맥에 의존한다
- 14.3.1 부수 효과로 간주되는 것은 무엇인가?
- 14.4 요약

##### 15장 스트림 처리와 점진적 입출력

- 15.1 명령식 입출력의 문제점을 보여주는 예제 하나
- 15.2 간단한 스트림 변환기
- 15.2.1 처리 공정의 생성
- 15.2.2 처리 공정의 합성과 추가
- 15.2.3 파일 처리
- 15.3 확장 가능한 처리 공정 형식
- 15.3.1 공급원
- 15.3.2 자원 안전성 보장
- 15.3.3 단일 입력 처리 공정
- 15.3.4 다중 입력 스트림
- 15.3.5 싱크
- 15.3.6 효과 있는 채널
- 15.3.7 동적 자원 할당
- 15.4 응용
- 15.5 요약
