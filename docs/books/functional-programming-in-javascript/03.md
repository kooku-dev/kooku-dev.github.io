---
title: 3장 자료구조는 적게, 일은 더 많이
---

:::note 이 장의 내용

- 프로그램 제어와 흐름
- 코드와 데이터를 효과적으로 헤아림
- map, reduce, filter의 진면목
- 로대시JS 라이브러리와 함수 체인
- 재귀적 사고방식

:::

:::note [컴퓨터 프로그램의 구조와 해석](인사이트, 2016) 1장에서

<div style={{ textAlign: 'center' }}>"계산 프로세스는 컴퓨터에 내재하는 추상적인 존재다. 이들이 점점 진화하면서 프로세스는 데이터라는 또 다른 추상적인 존재에 영향을 끼친다."</div>

:::

자료구조를 순차적으로 탐색/변환하는 데 쓰이는 실용적인 연산 및 가지(map, reduce, filter)를 소개합니다. 또 함수형 프로그래밍에서 재귀가 차지하는 막대한 비중에 대해 알아보고 재귀적인 사고방식이 어떤 점에서 좋은지 설명합니다. 

## 3.1 애플리케이션의 제어 흐름

프로그램이 정답에 이르기까지 거치는 경로를 **제어 흐름**이라고 합니다. 명령형 프로그램은 작업 수행에 필요한 전 단계를 노출하여 흐름이나 경로를 아주 자세히 서술합니다. 보통 작업을 수행하는 단계는 루프와 분기문, 구문마다 값이 바뀌는 변수들로 빼곡히 들어찹니다.

![img](./images/3.1.png)

반면, 선언적 프로그램, 특히 함수형 프로그램은 독자적인 블랙박스 연산들이 단순하게, 즉 최소한의 제어 구조를 통해 연결되어 추상화 수준이 높습니다. 이렇게 연결한 연산들은 각자 다음 연산으로 상태를 이동시키는 고계함수에 불과합니다. 실제로 함수형 프로그램은 데이터와 제어 흘므 자체를 고수준 컴포넌트 사이의 단순한 연결로 취급합니다.

![img](./images/3.2.png)

덕분에 다음과 같이 코드가 짧아집니다.

```js
optA().optB().optC().optD();
```

연산을 체이닝하면 간결하면서 물 흐르는 듯한, 표현적인 형태로 프로그램을 작성할 수 있어 제어 흐름과 계산 로직을 분리할 수 있고 코드와 데이터를 더욱 효과적으로 헤아릴 수 있습니다.

## 3.2 메서드 체이닝

**메서드 체이닝**은 여러 메서드를 단일 구문으로 호출하는 OOP 패턴입니다. 메서드가 모두 동일한 객체에 속해 있으면 메서드 흘리기라고도 합니다. 대부분 객체지향 프로그램에서 불변 객체에 많이 적용하는 패턴이지만 함수형 프로그래밍에도 잘 맞습니다.

```js
'Functional Programming'.substring(0, 10).toLowerCase() + ' is fun';
```

함수형으로 리팩터링한 코드는 다음과 같습니다.

```js
concat(toLowerCase(substring('Functional Programming', 1, 10)), 'is fun');
```

매개변수는 모두 함수 선언부에 명시해서 부수효과를 없애고 원본 객체를 바꾸지 않아야 한다는 함수형 교리를 충실히 반영한 코드입니다. 그러나 이렇게 함수 코드를 안쪽에서 바깥쪽으로 작성하면 메서드 체이닝 방식만큼 매끄럽지 못합니다. 로직을 파악하려면 가장 안쪽에 감싼 함수부터 한 꺼풀씩 벗겨내야 하고 가독성도 현저히 떨어지지요.

변이를 일으키지 않는 한 함수형 프로그래밍에서도 단일 객체 인스턴스에 속한 메서드를 체이닝하는 건 나름대로 쓸모가 있습니다.

## 3.3 함수 체이닝

객체지향 프로그램은 주로 상속을 통해 코드를 재사용합니다. 순수 객체지향 언어에서, 특히 언어 자체의 자료구조를 구현한 코드를 보면 이런 패턴이 자주 눈에 띕니다. 가령 자바세는 List 인터페이스를 용도에 맞게 달리 구현한 ArrayList, LinkedList, DoublyLinkedList, CopyOnWriteArrayList 등이 있습니다. 이들은 모두 한 부모에서 출발하여 나름대로 특수한 기능을 덧붙인 클래스입니다.

함수형 프로그래밍은 접근 방법이 다릅니다. 자료구조를 새로 만들어 어떤 요건을 충족시키는게 아니라, 배열 등의 흔한 자료구조를 이용해 다수의 굵게 나뉜 고계 연산을 적용합니다. 이러한 고계 연산으로 다음과 같은 일을 합니다.

- 작업을 수행하기 위해 무슨 일을 해야 하는지 기술된 함수를 인수로 받습니다.
- 임시 변수의 값을 계속 바꾸면서 부수효과를 일으키는 기존 수동 루프를 대체합니다. 그 결과 관리할 코드가 줄고 에러가 날 만한 코드 역시 줄어듭니다.

### 3.3.1 람다 표현식
함수형 프로그래밍에서 탄생한 **람다 표현식**은 한 줄짜리 익명 함수를 일반 함수 선언보다 단축된 구문으로 나타냅니다.

람다 표현식은 항상 어떤 값을 반환하게 만들어 함수 정의부를 확실히 함수형으로 굳힙니다. 

함수형 프로그래밍은 람다 표현식과 잘 어울리는 세 주요 고계함수 map, reduce, filter를 적극 사용할 것을 권장합니다. 사실 함수형 자바스크립트는 대부분 자료 리스트를 처리하는 코드입니다.

**lodashJs**는 개발자가 함수형 프로그램을 작성하도록 유도하는 중요한 장치를 제공하고, 여러 가지 공통적인 프로그래밍 작업을 처리하는 데 유용한 도우미 함수들을 풍성하게 제공합니다. 

:::info lodashJs 속 underscoreJs라는

lodashJs는 underscoreJs라는 유명 프로젝트에서 파생된 라이브러리이므로 underscoreJs의 관례를 따릅니다. 하지만 내부적으로는 함수 체인을 좀 더 우아하게 구축하는 방향으로 완전히 재작성되었고 성능 문제도 개선된 라이브러리입니다. 

:::

:::note 배열 축약

map, filter는 어떤 배열을 받아 새 배열을 내는 고계함수로, 하스켈, 클로저 등 대부분의 함수형 프로그래밍 언어에 기본 내장되어 있습니다. 이들을 조합하는 대신 **배열 축약**(또는 **리스트 축약**)이란 개념을 적용하는 방법도 있습니다. 배열 축약은 map, filter의 기능을 각각 for..of와 if 키워드를 이용하여 단축된 구문으로 캡슐화하는 함수형 장치입니다. 다음과 같은 형식입니다.

```js
[for (x of 이터러블) if (조건) x]
```

```js title="예시"
[for (p of people) if (p.birthYear === 1903) p.fullname].join(' and ');
```

:::

## 3.4 코드 헤아리기

앞에서 고수준 연산을 서로 연결하여 프로그램을 구축하는 것이 중요하다고 강조했습니다. 함수형 흐름은 프로그램 로직을 파헤치지 않아도 뭘 하는 프로그램인지 윤곽을 잡기 쉽기 때문에, 개발자는 코드뿐만 아니라, 결과를 내기 위해 서로 다른 단계를 드나드는 데이터의 흐름까지 더 깊이 헤아릴 수 있습니다.

### 3.4.1 선언적 코드와 느긋한 함수 체인
함수형 프로그램은 단순 함수들로 구성한다고 했습니다. 개별 함수가 하는 일은 보잘것 없지만, 함께 뭉치면 복잡한 작업도 할 수 있죠. 함수들을 연결해서 프로그램을 구성하는 방법을 살펴보겠습니다.

FP의 선언적 모델에 따르면, 프로그램이란 개별적인 순수함수들을 평가하는 과정이라고 볼 수 있습니다. 